---
import "../styles/global.css";
import { ViewTransitions } from 'astro:transitions';

const { title, subtitle, symbol } = Astro.props;
const base = import.meta.env.BASE_URL;

// Normalize current path for comparison
let currentPath = Astro.url.pathname;
// Ensure trailing slash
if (!currentPath.endsWith('/')) {
    currentPath += '/';
}

const navLinks = [
    { href: `${base}/`, label: "HOME" },
    { href: `${base}/new-testament/`, label: "NEW TESTAMENT" },
    { href: `${base}/old-testament/`, label: "OLD TESTAMENT" },
    { href: `${base}/lilith/`, label: "LILITH" },
    { href: `${base}/demonology/`, label: "DEMONOLOGY" },
    { href: `${base}/symbolism/`, label: "SYMBOLISM" },
    { href: `${base}/collective-unconscious/`, label: "UNCONSCIOUS" },
    { href: `${base}/lexicon/`, label: "LEXICON" },
];
---

<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>{title} | Silent Hill Biblical Themes</title>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Special+Elite&family=Share+Tech+Mono&display=swap" rel="stylesheet">
        <ViewTransitions />
    </head>
    <body>
        <!-- Background music -->
        <audio id="background-music" loop preload="auto" transition:persist="bgmusic">
            <source src={`${base}/fairy.mp3`} type="audio/mpeg">
        </audio>

        <!-- Blood & Horror atmosphere layers -->
        <div class="blood-layer" aria-hidden="true" id="blood-layer" transition:persist="blood"></div>
        <div class="blood-glow" aria-hidden="true" id="blood-glow" transition:persist="glow"></div>
        <div class="fog-layer" aria-hidden="true" id="fog-layer" transition:persist="fog"></div>
        <div class="fog-haze" aria-hidden="true" id="fog-haze" transition:persist="haze"></div>
        <div class="vignette" aria-hidden="true" id="vignette" transition:persist="vignette"></div>
        <div class="scanlines" aria-hidden="true" transition:persist="scanlines"></div>
        <div class="static-noise" id="static-noise" aria-hidden="true" transition:persist="static"></div>

        <!-- Jumpscare overlay -->
        <div class="jumpscare-overlay" id="jumpscare-overlay" transition:persist="jumpscare">
            <div class="scare-content" id="scare-content"></div>
        </div>

        <!-- Audio indicator -->
        <div class="audio-indicator" id="audio-toggle" transition:persist="audio-toggle">
            <span class="icon">â™ª</span>
            <span class="label">PLAY</span>
        </div>

        <nav transition:persist="nav">
            <ul>
                {
                    navLinks.map((link) => (
                        <li>
                            <a
                                href={link.href}
                                class={currentPath === link.href ? "active" : ""}
                                data-text={link.label}
                            >
                                {link.label}
                            </a>
                        </li>
                    ))
                }
            </ul>
        </nav>

        {
            title !== "Silent Hill" && (
                <header>
                    <div class="symbol glitch-text">{symbol}</div>
                    <h1 class="glitch-text">{title}</h1>
                    <div class="subtitle">{subtitle}</div>
                    <div class="header-border"></div>
                </header>
            )
        }

        <div class="container page-content">
            <main>
                <slot />
            </main>
        </div>

        <footer>
            <div class="motto">â˜© IN STERQUILINIIS INVENITUR â˜©</div>
            <div class="translation">"In the dirt, it will be found"</div>
        </footer>

        <script>
            // @ts-ignore - Motion library types don't include all CSS properties
            import { animate, scroll } from "motion";

            // ============================================
            // DARK RED BLOOD HORROR ENGINE
            // Motion-powered animations
            // ============================================

            class BloodHorrorEngine {
                // Audio System Properties
                audioContext: AudioContext | null;
                audioEnabled: boolean;
                audioInitialized: boolean;
                oscillators: OscillatorNode[];
                gainNodes: GainNode[];
                bgMusic: HTMLAudioElement | null;
                musicStarted: boolean;

                // Horror Effect Properties
                lastInteraction: number;
                jumpscareTriggered: boolean;
                whisperCount: number;
                maxWhispers: number;
                whispers: string[];
                scareSymbols: string[];

                // Accessibility
                prefersReducedMotion: boolean;

                constructor() {
                    this.audioContext = null;
                    this.audioEnabled = false;
                    this.audioInitialized = false;
                    this.oscillators = [];
                    this.gainNodes = [];
                    this.lastInteraction = Date.now();
                    this.jumpscareTriggered = false;
                    this.whisperCount = 0;
                    this.maxWhispers = 3;
                    this.bgMusic = null;
                    this.musicStarted = false;
                    this.prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

                    this.whispers = [
                        "The blood...",
                        "It never stops...",
                        "Can you see it?",
                        "The walls are bleeding",
                        "Silent Hill",
                        "In my restless dreams",
                        "I see that town",
                        "There was a hole here",
                        "It's gone now",
                        "Born from a wish",
                        "Forgive me",
                        "The darkness",
                        "Red pyramid",
                        "Behind you",
                        "Don't look",
                        "Turn back",
                        "Dead people don't write letters",
                        "Mary...",
                        "James...",
                        "You killed her",
                        "The monster",
                        "Something's wrong"
                    ];

                    this.scareSymbols = ['â˜ ', 'âœ', 'â˜©', 'â›§', 'â€ ', 'â˜ ', 'ðŸ’€', 'â›§'];

                    this.init();
                }

                init() {
                    this.setupBackgroundMusic();
                    this.setupAudioToggle();

                    if (!this.prefersReducedMotion) {
                        this.setupMotionAnimations();
                        this.setupGlitchEffects();
                        this.setupWhispers();
                        this.setupJumpscares();
                        this.setupScrollEffects();
                        this.setupIdleDetection();
                        this.setupRandomEvents();
                    }

                    this.setupPageLoad();
                }

                // ============================================
                // BACKGROUND MUSIC (AUTOPLAY BYPASS)
                // ============================================
                setupBackgroundMusic() {
                    this.bgMusic = document.getElementById('background-music') as HTMLAudioElement | null;
                    if (!this.bgMusic) return;

                    this.bgMusic.volume = 0.4;

                    // Try immediate play (works if user has interacted before)
                    this.tryPlayMusic();

                    // Listen for first interaction to trigger playback
                    const startMusic = () => {
                        this.tryPlayMusic();
                    };

                    ['click', 'scroll', 'keydown', 'touchstart', 'mousemove'].forEach(event => {
                        document.addEventListener(event, startMusic, { once: false, passive: true });
                    });

                    // Try when user returns to tab
                    document.addEventListener('visibilitychange', () => {
                        if (document.visibilityState === 'visible') {
                            this.tryPlayMusic();
                        }
                    });
                }

                tryPlayMusic() {
                    if (this.musicStarted || !this.bgMusic) return;

                    const playPromise = this.bgMusic.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            this.musicStarted = true;
                            this.audioEnabled = true;
                            document.getElementById('audio-toggle')?.classList.remove('muted');
                            this.updateAudioIndicatorText();
                        }).catch(() => {
                            // Autoplay prevented, will try again on interaction
                        });
                    }
                }

                // ============================================
                // MOTION ANIMATIONS
                // ============================================
                setupMotionAnimations() {
                    // Blood layer pulsing
                    const bloodLayer = document.getElementById('blood-layer');
                    if (bloodLayer) {
                        animate(
                            bloodLayer,
                            {
                                opacity: [1, 0.85, 1],
                                filter: ['brightness(1)', 'brightness(1.1)', 'brightness(1)']
                            } as any,
                            { duration: 8, repeat: Infinity, easing: 'ease-in-out' } as any
                        );
                    }

                    // Blood glow flickering
                    const bloodGlow = document.getElementById('blood-glow');
                    if (bloodGlow) {
                        animate(
                            bloodGlow,
                            { opacity: [0.8, 0.6, 0.9, 0.7, 0.8] } as any,
                            { duration: 0.6, repeat: Infinity } as any
                        );
                    }

                    // Fog drift
                    const fogLayer = document.getElementById('fog-layer');
                    if (fogLayer) {
                        animate(
                            fogLayer,
                            { x: ['0%', '-66.666%'] } as any,
                            { duration: 120, repeat: Infinity, easing: 'linear' } as any
                        );
                    }

                    // Fog haze pulse
                    const fogHaze = document.getElementById('fog-haze');
                    if (fogHaze) {
                        animate(
                            fogHaze,
                            { opacity: [0.5, 0.8, 0.5] } as any,
                            { duration: 15, repeat: Infinity, easing: 'ease-in-out' } as any
                        );
                    }

                    // Vignette breathing
                    const vignette = document.getElementById('vignette');
                    if (vignette) {
                        animate(
                            vignette,
                            { opacity: [1, 0.85, 1] } as any,
                            { duration: 6, repeat: Infinity, easing: 'ease-in-out' } as any
                        );
                    }

                    // Scanlines movement
                    const scanlines = document.querySelector('.scanlines');
                    if (scanlines) {
                        animate(
                            scanlines,
                            { y: [0, 4] } as any,
                            { duration: 10, repeat: Infinity, easing: 'linear' } as any
                        );
                    }

                    // Static noise flicker
                    const staticNoise = document.getElementById('static-noise');
                    if (staticNoise) {
                        animate(
                            staticNoise,
                            { opacity: [0.03, 0.06, 0.03] } as any,
                            { duration: 0.1, repeat: Infinity } as any
                        );
                    }
                }

                setupPageLoad() {
                    // Simple instant fade - "old web" feel
                    const pageContent = document.querySelector('.page-content');
                    if (pageContent) {
                        if (this.prefersReducedMotion) {
                            (pageContent as HTMLElement).style.opacity = '1';
                        } else {
                            animate(
                                pageContent,
                                { opacity: [0, 1] } as any,
                                { duration: 0.15, easing: 'ease-out' } as any
                            );
                        }
                    }

                    // Only setup breathing effects if motion is allowed
                    if (this.prefersReducedMotion) return;

                    // Symbol breathing effects (header)
                    const headerSymbol = document.querySelector('header .symbol');
                    if (headerSymbol) {
                        animate(
                            headerSymbol,
                            {
                                textShadow: [
                                    '0 0 20px rgba(153, 0, 0, 0.4), 0 0 30px rgba(204, 0, 0, 0.5)',
                                    '0 0 30px rgba(153, 0, 0, 0.6), 0 0 50px rgba(204, 0, 0, 0.7)',
                                    '0 0 20px rgba(153, 0, 0, 0.4), 0 0 30px rgba(204, 0, 0, 0.5)'
                                ]
                            } as any,
                            { duration: 4, repeat: Infinity, easing: 'ease-in-out' } as any
                        );
                    }

                    // Home symbol breathing
                    const bigSymbol = document.querySelector('.home-intro .big-symbol');
                    if (bigSymbol) {
                        animate(
                            bigSymbol,
                            {
                                textShadow: [
                                    '0 0 30px rgba(153, 0, 0, 0.6), 0 0 60px rgba(204, 0, 0, 0.5)',
                                    '0 0 40px rgba(153, 0, 0, 0.8), 0 0 80px rgba(204, 0, 0, 0.7)',
                                    '0 0 30px rgba(153, 0, 0, 0.6), 0 0 60px rgba(204, 0, 0, 0.5)'
                                ]
                            } as any,
                            { duration: 4, repeat: Infinity, easing: 'ease-in-out' } as any
                        );
                    }

                    // Parallax scroll for blood layer
                    const bloodLayerEl = document.getElementById('blood-layer');
                    if (bloodLayerEl) {
                        scroll(
                            animate(bloodLayerEl, { y: [0, -100] } as any) as any,
                            { target: document.body } as any
                        );
                    }
                }

                // ============================================
                // AUDIO SYSTEM
                // ============================================
                setupAudioToggle() {
                    const toggle = document.getElementById('audio-toggle');
                    if (!toggle) return;

                    toggle.addEventListener('click', () => {
                        if (!this.audioInitialized) {
                            this.initAudio();
                        } else {
                            this.toggleAudio();
                        }
                    });
                }

                initAudio() {
                    try {
                        this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
                        this.audioInitialized = true;
                        this.audioEnabled = true;
                        document.getElementById('audio-toggle')?.classList.remove('muted');
                        this.updateAudioIndicatorText();
                        this.startAmbientDrone();
                    } catch (e) {
                        console.log('Audio not supported');
                    }
                }

                toggleAudio() {
                    this.audioEnabled = !this.audioEnabled;
                    const toggle = document.getElementById('audio-toggle');

                    if (this.audioEnabled) {
                        toggle?.classList.remove('muted');
                        if (this.bgMusic) {
                            this.bgMusic.play();
                            this.musicStarted = true;
                        }
                        this.startAmbientDrone();
                    } else {
                        toggle?.classList.add('muted');
                        if (this.bgMusic) {
                            this.bgMusic.pause();
                        }
                        this.stopAllAudio();
                    }
                    this.updateAudioIndicatorText();
                }

                updateAudioIndicatorText() {
                    const toggle = document.getElementById('audio-toggle');
                    const label = toggle?.querySelector('.label');
                    if (!label) return;

                    label.textContent = this.audioEnabled ? 'PAUSE' : 'PLAY';
                }

                startAmbientDrone() {
                    if (!this.audioContext || !this.audioEnabled) return;

                    // Deep bass drone
                    const bassOsc = this.audioContext.createOscillator();
                    const bassGain = this.audioContext.createGain();
                    bassOsc.type = 'sine';
                    bassOsc.frequency.setValueAtTime(40, this.audioContext.currentTime);
                    bassGain.gain.setValueAtTime(0.08, this.audioContext.currentTime);
                    bassOsc.connect(bassGain);
                    bassGain.connect(this.audioContext.destination);
                    bassOsc.start();
                    this.oscillators.push(bassOsc);
                    this.gainNodes.push(bassGain);

                    // Eerie high frequency
                    const highOsc = this.audioContext.createOscillator();
                    const highGain = this.audioContext.createGain();
                    highOsc.type = 'sine';
                    highOsc.frequency.setValueAtTime(880, this.audioContext.currentTime);
                    highGain.gain.setValueAtTime(0.015, this.audioContext.currentTime);
                    highOsc.connect(highGain);
                    highGain.connect(this.audioContext.destination);
                    highOsc.start();
                    this.oscillators.push(highOsc);
                    this.gainNodes.push(highGain);

                    this.modulateAmbient();
                }

                modulateAmbient() {
                    if (!this.audioEnabled || !this.audioContext) return;

                    const now = this.audioContext.currentTime;

                    this.oscillators.forEach((osc, i) => {
                        const baseFreq = i === 0 ? 40 : 880;
                        const variation = (Math.random() - 0.5) * (i === 0 ? 10 : 100);
                        osc.frequency.setTargetAtTime(baseFreq + variation, now, 2);
                    });

                    this.gainNodes.forEach((gain, i) => {
                        const baseGain = i === 0 ? 0.08 : 0.015;
                        const variation = (Math.random() - 0.5) * 0.03;
                        gain.gain.setTargetAtTime(Math.max(0, baseGain + variation), now, 1);
                    });

                    setTimeout(() => this.modulateAmbient(), 3000 + Math.random() * 4000);
                }

                stopAllAudio() {
                    this.oscillators.forEach(osc => {
                        try { osc.stop(); } catch(e) {}
                    });
                    this.oscillators = [];
                    this.gainNodes = [];
                }

                playJumpscareSound() {
                    if (!this.audioContext || !this.audioEnabled) return;

                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();

                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, this.audioContext.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.3);

                    gain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);

                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    osc.start();
                    osc.stop(this.audioContext.currentTime + 0.4);
                }

                playWhisperSound() {
                    if (!this.audioContext || !this.audioEnabled) return;

                    const bufferSize = this.audioContext.sampleRate * 0.5;
                    const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    const data = buffer.getChannelData(0);

                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = (Math.random() * 2 - 1) * 0.1;
                    }

                    const source = this.audioContext.createBufferSource();
                    source.buffer = buffer;

                    const filter = this.audioContext.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.setValueAtTime(1000, this.audioContext.currentTime);
                    filter.Q.setValueAtTime(5, this.audioContext.currentTime);

                    const gain = this.audioContext.createGain();
                    gain.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gain.gain.linearRampToValueAtTime(0.1, this.audioContext.currentTime + 0.1);
                    gain.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 0.5);

                    source.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.audioContext.destination);
                    source.start();
                }

                // ============================================
                // GLITCH EFFECTS
                // ============================================
                setupGlitchEffects() {
                    const triggerGlitch = () => {
                        const elements = document.querySelectorAll('.glitch-text');
                        if (elements.length === 0) return;

                        const el = elements[Math.floor(Math.random() * elements.length)];

                        animate(
                            el,
                            {
                                x: [-2, 2, -2, 0],
                                y: [1, -1, 1, 0],
                                textShadow: [
                                    'inherit',
                                    '-3px 0 #cc0000, 3px 0 #990000',
                                    '3px 0 #cc0000, -3px 0 #990000',
                                    'inherit'
                                ]
                            } as any,
                            { duration: 0.3, easing: 'ease-out' } as any
                        );

                        setTimeout(triggerGlitch, 5000 + Math.random() * 15000);
                    };

                    setTimeout(triggerGlitch, 3000);
                }

                triggerStaticBurst() {
                    const staticEl = document.getElementById('static-noise');
                    if (!staticEl) return;

                    staticEl.classList.add('active');
                    animate(
                        staticEl,
                        { opacity: [0.5, 0.03] } as any,
                        { duration: 0.5, easing: 'ease-out' } as any
                    );
                    setTimeout(() => staticEl.classList.remove('active'), 500);
                }

                triggerHeavyGlitch() {
                    const body = document.body;

                    animate(
                        body,
                        {
                            x: [-5, 5, -3, 3, 0],
                            skewX: [-2, 2, 0],
                            filter: [
                                'none',
                                'hue-rotate(90deg)',
                                'saturate(2) contrast(1.5)',
                                'invert(1)',
                                'none'
                            ]
                        } as any,
                        { duration: 0.4, easing: 'ease-out' } as any
                    );

                    this.triggerStaticBurst();
                }

                // ============================================
                // WHISPERS
                // ============================================
                setupWhispers() {
                    const showWhisper = () => {
                        if (this.whisperCount >= this.maxWhispers) {
                            this.whisperCount = 0;
                        }

                        const text = this.whispers[Math.floor(Math.random() * this.whispers.length)];
                        const whisper = document.createElement('div');
                        whisper.className = 'whisper';
                        whisper.textContent = text;
                        whisper.style.left = (10 + Math.random() * 70) + '%';
                        whisper.style.top = (10 + Math.random() * 70) + '%';
                        whisper.style.transform = `rotate(${(Math.random() - 0.5) * 20}deg)`;

                        document.body.appendChild(whisper);
                        this.playWhisperSound();
                        this.whisperCount++;

                        animate(
                            whisper,
                            {
                                opacity: [0, 0.4, 0.3, 0],
                                filter: ['blur(10px)', 'blur(2px)', 'blur(2px)', 'blur(10px)']
                            } as any,
                            { duration: 4, easing: 'ease-out' } as any
                        );

                        setTimeout(() => whisper.remove(), 4000);
                        setTimeout(showWhisper, 20000 + Math.random() * 40000);
                    };

                    setTimeout(showWhisper, 15000 + Math.random() * 20000);
                }

                // ============================================
                // JUMPSCARES
                // ============================================
                setupJumpscares() {
                    document.addEventListener('scroll', () => {
                        if (Math.random() < 0.002 && !this.jumpscareTriggered) {
                            this.triggerMiniScare();
                        }
                    });
                }

                triggerMiniScare() {
                    if (this.jumpscareTriggered) return;
                    this.jumpscareTriggered = true;

                    this.triggerHeavyGlitch();
                    this.playJumpscareSound();

                    setTimeout(() => {
                        this.jumpscareTriggered = false;
                    }, 30000);
                }

                triggerFullJumpscare() {
                    const overlay = document.getElementById('jumpscare-overlay');
                    const content = document.getElementById('scare-content');
                    if (!overlay || !content) return;

                    content.innerHTML = this.scareSymbols[Math.floor(Math.random() * this.scareSymbols.length)];
                    overlay.classList.add('active');
                    this.playJumpscareSound();
                    this.triggerStaticBurst();

                    animate(
                        content,
                        {
                            x: [-10, 10, -5, 5, 0],
                            y: [5, -5, -10, 5, 0],
                            rotate: [-2, 2, -1, 1, 0]
                        } as any,
                        { duration: 0.2, repeat: 2 } as any
                    );

                    animate(
                        overlay,
                        {
                            background: ['#ffffff', '#cc0000', '#000000']
                        } as any,
                        { duration: 0.4, easing: 'ease-out' } as any
                    );

                    setTimeout(() => {
                        overlay.classList.remove('active');
                    }, 400);
                }

                // ============================================
                // SCROLL EFFECTS
                // ============================================
                setupScrollEffects() {
                    let lastScroll = 0;
                    let scrollVelocity = 0;

                    window.addEventListener('scroll', () => {
                        const currentScroll = window.scrollY;
                        scrollVelocity = Math.abs(currentScroll - lastScroll);
                        lastScroll = currentScroll;

                        if (scrollVelocity > 100) {
                            this.triggerStaticBurst();
                        }

                        if (scrollVelocity > 200 && Math.random() < 0.1) {
                            this.triggerMiniScare();
                        }
                    });
                }

                // ============================================
                // IDLE DETECTION
                // ============================================
                setupIdleDetection() {
                    setInterval(() => {
                        const idleTime = Date.now() - this.lastInteraction;

                        if (idleTime > 30000 && Math.random() < 0.05) {
                            this.showIdleWhisper();
                        }

                        if (idleTime > 60000 && Math.random() < 0.02) {
                            this.triggerMiniScare();
                        }
                    }, 5000);

                    ['mousemove', 'keydown', 'scroll', 'click'].forEach(event => {
                        document.addEventListener(event, () => {
                            this.lastInteraction = Date.now();
                        });
                    });
                }

                showIdleWhisper() {
                    const text = this.whispers[Math.floor(Math.random() * this.whispers.length)];
                    const whisper = document.createElement('div');
                    whisper.className = 'whisper';
                    whisper.textContent = text;
                    whisper.style.left = (20 + Math.random() * 60) + '%';
                    whisper.style.top = (20 + Math.random() * 60) + '%';

                    document.body.appendChild(whisper);
                    this.playWhisperSound();

                    animate(
                        whisper,
                        {
                            opacity: [0, 0.4, 0],
                            filter: ['blur(10px)', 'blur(2px)', 'blur(10px)']
                        } as any,
                        { duration: 4, easing: 'ease-out' } as any
                    );

                    setTimeout(() => whisper.remove(), 4000);
                }

                // ============================================
                // RANDOM EVENTS
                // ============================================
                setupRandomEvents() {
                    setInterval(() => {
                        if (Math.random() < 0.03) {
                            this.screenFlicker();
                        }
                    }, 10000);

                    setInterval(() => {
                        if (Math.random() < 0.05) {
                            this.distortRandomText();
                        }
                    }, 15000);
                }

                screenFlicker() {
                    const body = document.body;

                    animate(
                        body,
                        { filter: ['brightness(1)', 'brightness(0.3)', 'brightness(1.5)', 'brightness(0.5)', 'brightness(1)'] } as any,
                        { duration: 0.13, easing: 'steps(4)' } as any
                    );
                }

                distortRandomText() {
                    const paragraphs = document.querySelectorAll('main p');
                    if (paragraphs.length === 0) return;

                    const p = paragraphs[Math.floor(Math.random() * paragraphs.length)];

                    animate(
                        p,
                        {
                            color: ['inherit', '#990000', 'inherit'],
                            textShadow: ['none', '0 0 10px rgba(153, 0, 0, 0.6)', 'none']
                        } as any,
                        { duration: 2, easing: 'ease-in-out' } as any
                    );
                }
            }

            // Single instance of horror engine
            let horrorEngine: BloodHorrorEngine | null = null;

            // Updates the active navigation link indicator during view transitions
            // Handles Astro's client-side navigation without page refresh
            function updateActiveNavLink() {
                // Normalize current path with trailing slash
                let currentPath = window.location.pathname;
                if (!currentPath.endsWith('/')) {
                    currentPath += '/';
                }

                // Update active class on all nav links
                const navLinks = document.querySelectorAll('nav a');
                navLinks.forEach(link => {
                    link.classList.remove('active');

                    // Check if link href matches current path
                    const linkHref = link.getAttribute('href');
                    if (linkHref === currentPath) {
                        link.classList.add('active');
                    }
                });
            }

            function initHorrorEngine() {
                if (!horrorEngine) {
                    horrorEngine = new BloodHorrorEngine();
                } else {
                    // On page swap, just reinitialize page-specific animations
                    horrorEngine.setupPageLoad();
                }
            }

            // Initialize on first load
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    initHorrorEngine();
                    updateActiveNavLink();
                });
            } else {
                initHorrorEngine();
                updateActiveNavLink();
            }

            // Reinitialize page content on Astro navigation
            document.addEventListener('astro:after-swap', () => {
                if (horrorEngine) {
                    horrorEngine.setupPageLoad();
                }
            });

            // Update active nav link on Astro page transitions
            document.addEventListener('astro:page-load', updateActiveNavLink);
        </script>
    </body>
</html>
