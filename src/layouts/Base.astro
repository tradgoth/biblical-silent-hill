---
import "../styles/global.css";
import { ViewTransitions } from 'astro:transitions';

const { title, subtitle, symbol } = Astro.props;
const base = import.meta.env.BASE_URL;

// Normalize current path for comparison
let currentPath = Astro.url.pathname;
// Ensure trailing slash
if (!currentPath.endsWith('/')) {
    currentPath += '/';
}

const navLinks = [
    { href: `${base}/`, label: "HOME" },
    { href: `${base}/new-testament/`, label: "NEW TESTAMENT" },
    { href: `${base}/old-testament/`, label: "OLD TESTAMENT" },
    { href: `${base}/lilith/`, label: "LILITH" },
    { href: `${base}/demonology/`, label: "DEMONOLOGY" },
    { href: `${base}/symbolism/`, label: "SYMBOLISM" },
    { href: `${base}/collective-unconscious/`, label: "UNCONSCIOUS" },
    { href: `${base}/lexicon/`, label: "LEXICON" },
];
---

<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>{title} | Silent Hill Biblical Themes</title>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Special+Elite&family=Share+Tech+Mono&display=swap" rel="stylesheet">
        <ViewTransitions />
    </head>
    <body>
        <!-- Background music -->
        <audio id="background-music" loop preload="auto" transition:persist="bgmusic">
            <source src={`${base}/fairy.mp3`} type="audio/mpeg">
        </audio>

        <!-- Blood & Horror atmosphere layers -->
        <div class="blood-layer" aria-hidden="true" id="blood-layer" transition:persist="blood"></div>
        <div class="blood-glow" aria-hidden="true" id="blood-glow" transition:persist="glow"></div>
        <div class="fog-layer" aria-hidden="true" id="fog-layer" transition:persist="fog"></div>
        <div class="fog-haze" aria-hidden="true" id="fog-haze" transition:persist="haze"></div>
        <div class="vignette" aria-hidden="true" id="vignette" transition:persist="vignette"></div>
        <div class="scanlines" aria-hidden="true" transition:persist="scanlines"></div>
        <div class="static-noise" id="static-noise" aria-hidden="true" transition:persist="static"></div>

        <!-- Jumpscare overlay -->
        <div class="jumpscare-overlay" id="jumpscare-overlay" transition:persist="jumpscare">
            <div class="scare-content" id="scare-content"></div>
        </div>

        <!-- Audio indicator -->
        <div class="audio-indicator muted" id="audio-toggle" transition:persist="audio-toggle">
            <span class="icon">‚ô™</span>
        </div>

        <nav transition:persist="nav">
            <ul>
                {
                    navLinks.map((link) => (
                        <li>
                            <a
                                href={link.href}
                                class={currentPath === link.href ? "active" : ""}
                                data-text={link.label}
                            >
                                {link.label}
                            </a>
                        </li>
                    ))
                }
            </ul>
        </nav>

        {
            title !== "Silent Hill" && (
                <header>
                    <div class="symbol glitch-text">{symbol}</div>
                    <h1 class="glitch-text">{title}</h1>
                    <div class="subtitle">{subtitle}</div>
                    <div class="header-border"></div>
                </header>
            )
        }

        <div class="container page-content">
            <main>
                <slot />
            </main>
        </div>

        <footer>
            <div class="motto">‚ò© IN STERQUILINIIS INVENITUR ‚ò©</div>
            <div class="translation">"In the dirt, it will be found"</div>
        </footer>

        <script>
            // @ts-ignore - Motion library types don't include all CSS properties
            import { animate, scroll } from "motion";

            // ============================================
            // DARK RED BLOOD HORROR ENGINE
            // Performance-optimized horror system
            // ============================================

            // Performance mode detection
            type PerformanceMode = 'high' | 'medium' | 'low';

            class BloodHorrorEngine {
                // Audio System Properties
                audioContext: AudioContext | null;
                audioEnabled: boolean;
                audioInitialized: boolean;
                oscillators: OscillatorNode[];
                gainNodes: GainNode[];
                bgMusic: HTMLAudioElement | null;
                musicStarted: boolean;

                // Horror Effect Properties
                lastInteraction: number;
                jumpscareTriggered: boolean;
                whisperCount: number;
                maxWhispers: number;
                whispers: string[];
                scareSymbols: string[];

                // Accessibility & Performance
                prefersReducedMotion: boolean;
                performanceMode: PerformanceMode;

                // Cached DOM elements - avoid repeated queries
                cachedElements: {
                    bloodLayer: HTMLElement | null;
                    bloodGlow: HTMLElement | null;
                    fogLayer: HTMLElement | null;
                    fogHaze: HTMLElement | null;
                    vignette: HTMLElement | null;
                    scanlines: Element | null;
                    staticNoise: HTMLElement | null;
                    jumpscareOverlay: HTMLElement | null;
                    scareContent: HTMLElement | null;
                    audioToggle: HTMLElement | null;
                    main: HTMLElement | null;
                    pageContent: HTMLElement | null;
                    headerSymbol: Element | null;
                    bigSymbol: Element | null;
                    glitchTexts: Element[];
                    paragraphs: Element[];
                };

                // Whisper element pool - reuse instead of create/destroy
                whisperPool: HTMLElement[];
                whisperPoolIndex: number;

                // RAF loop management
                rafId: number | null;
                lastFrameTime: number;
                tickCounter: number;

                constructor() {
                    this.audioContext = null;
                    this.audioEnabled = false;
                    this.audioInitialized = false;
                    this.oscillators = [];
                    this.gainNodes = [];
                    this.lastInteraction = Date.now();
                    this.jumpscareTriggered = false;
                    this.whisperCount = 0;
                    this.maxWhispers = 3;
                    this.bgMusic = null;
                    this.musicStarted = false;
                    this.prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

                    // Detect device performance
                    this.performanceMode = this.detectPerformance();

                    // Initialize cached elements
                    this.cachedElements = {
                        bloodLayer: null,
                        bloodGlow: null,
                        fogLayer: null,
                        fogHaze: null,
                        vignette: null,
                        scanlines: null,
                        staticNoise: null,
                        jumpscareOverlay: null,
                        scareContent: null,
                        audioToggle: null,
                        main: null,
                        pageContent: null,
                        headerSymbol: null,
                        bigSymbol: null,
                        glitchTexts: [],
                        paragraphs: []
                    };

                    // Whisper pool for element reuse
                    this.whisperPool = [];
                    this.whisperPoolIndex = 0;

                    // RAF loop state
                    this.rafId = null;
                    this.lastFrameTime = 0;
                    this.tickCounter = 0;

                    this.whispers = [
                        "The blood...",
                        "It never stops...",
                        "Can you see it?",
                        "The walls are bleeding",
                        "Silent Hill",
                        "In my restless dreams",
                        "I see that town",
                        "There was a hole here",
                        "It's gone now",
                        "Born from a wish",
                        "Forgive me",
                        "The darkness",
                        "Red pyramid",
                        "Behind you",
                        "Don't look",
                        "Turn back",
                        "Dead people don't write letters",
                        "Mary...",
                        "James...",
                        "You killed her",
                        "The monster",
                        "Something's wrong"
                    ];

                    this.scareSymbols = ['‚ò†', '‚úù', '‚ò©', '‚õß', '‚Ä†', '‚ò†', 'üíÄ', '‚õß'];

                    this.init();
                }

                // ============================================
                // PERFORMANCE DETECTION
                // ============================================
                detectPerformance(): PerformanceMode {
                    // Check for low-end device indicators
                    const hardwareConcurrency = navigator.hardwareConcurrency || 2;
                    const deviceMemory = (navigator as any).deviceMemory || 4;
                    const connection = (navigator as any).connection;
                    const saveData = connection?.saveData || false;
                    const effectiveType = connection?.effectiveType || '4g';

                    // Low performance: limited cores, low memory, or data saver
                    if (hardwareConcurrency <= 2 || deviceMemory <= 2 || saveData) {
                        console.log('[Horror] Low performance mode - minimal effects');
                        return 'low';
                    }

                    // Medium performance: moderate specs or slow connection
                    if (hardwareConcurrency <= 4 || deviceMemory <= 4 || effectiveType === '3g' || effectiveType === '2g') {
                        console.log('[Horror] Medium performance mode - reduced effects');
                        return 'medium';
                    }

                    console.log('[Horror] High performance mode - full effects');
                    return 'high';
                }

                // ============================================
                // DOM CACHING
                // ============================================
                cacheElements() {
                    this.cachedElements = {
                        bloodLayer: document.getElementById('blood-layer'),
                        bloodGlow: document.getElementById('blood-glow'),
                        fogLayer: document.getElementById('fog-layer'),
                        fogHaze: document.getElementById('fog-haze'),
                        vignette: document.getElementById('vignette'),
                        scanlines: document.querySelector('.scanlines'),
                        staticNoise: document.getElementById('static-noise'),
                        jumpscareOverlay: document.getElementById('jumpscare-overlay'),
                        scareContent: document.getElementById('scare-content'),
                        audioToggle: document.getElementById('audio-toggle'),
                        main: document.querySelector('main'),
                        pageContent: document.querySelector('.page-content') as HTMLElement | null,
                        headerSymbol: document.querySelector('header .symbol'),
                        bigSymbol: document.querySelector('.home-intro .big-symbol'),
                        glitchTexts: Array.from(document.querySelectorAll('.glitch-text')),
                        paragraphs: []  // Lazily cached when needed
                    };
                }

                // Lazy cache paragraphs only when needed
                getParagraphs(): Element[] {
                    if (this.cachedElements.paragraphs.length === 0 && this.cachedElements.main) {
                        this.cachedElements.paragraphs = Array.from(this.cachedElements.main.querySelectorAll('p'));
                    }
                    return this.cachedElements.paragraphs;
                }

                // ============================================
                // WHISPER POOL
                // ============================================
                initWhisperPool() {
                    const poolSize = this.performanceMode === 'low' ? 2 : 4;
                    for (let i = 0; i < poolSize; i++) {
                        const whisper = document.createElement('div');
                        whisper.className = 'whisper';
                        whisper.style.display = 'none';
                        whisper.style.willChange = 'opacity, filter, transform';
                        document.body.appendChild(whisper);
                        this.whisperPool.push(whisper);
                    }
                }

                getPooledWhisper(): HTMLElement {
                    const whisper = this.whisperPool[this.whisperPoolIndex];
                    this.whisperPoolIndex = (this.whisperPoolIndex + 1) % this.whisperPool.length;
                    return whisper;
                }

                init() {
                    // Cache all DOM elements first
                    this.cacheElements();

                    this.setupBackgroundMusic();
                    this.setupAudioToggle();

                    if (!this.prefersReducedMotion) {
                        // Initialize whisper pool for element reuse
                        this.initWhisperPool();

                        // Add will-change hints to animated elements
                        this.addWillChangeHints();

                        // Use CSS animations for backgrounds (much lighter than JS)
                        this.enableCSSAnimations();

                        // Only setup JS animations on high/medium performance
                        if (this.performanceMode !== 'low') {
                            this.setupGlitchEffects();
                        }

                        // Setup pooled whispers
                        this.setupWhispers();
                        this.setupJumpscares();
                        this.setupScrollEffects();

                        // Start unified RAF loop instead of multiple timers
                        this.startMainLoop();

                        this.setupInteractiveElements();
                        this.setupKeyboardEasterEggs();
                    }

                    this.setupPageLoad();
                }

                // ============================================
                // WILL-CHANGE HINTS
                // ============================================
                addWillChangeHints() {
                    const { bloodLayer, bloodGlow, vignette, staticNoise } = this.cachedElements;
                    if (bloodLayer) bloodLayer.style.willChange = 'opacity';
                    if (bloodGlow) bloodGlow.style.willChange = 'opacity';
                    if (vignette) vignette.style.willChange = 'opacity';
                    if (staticNoise) staticNoise.style.willChange = 'opacity';
                }

                // ============================================
                // CSS ANIMATIONS (GPU-accelerated, no JS overhead)
                // ============================================
                enableCSSAnimations() {
                    const { bloodLayer, bloodGlow, fogLayer, fogHaze, vignette, scanlines, staticNoise } = this.cachedElements;

                    // Blood layer pulse - pure CSS
                    if (bloodLayer) {
                        bloodLayer.style.animation = 'bloodPulse 12s ease-in-out infinite';
                    }

                    // Blood glow flicker - pure CSS (skip on low performance)
                    if (bloodGlow && this.performanceMode !== 'low') {
                        bloodGlow.style.animation = 'bloodFlicker 0.8s ease-in-out infinite';
                    }

                    // Fog drift - pure CSS
                    if (fogLayer) {
                        fogLayer.style.animation = this.performanceMode === 'low'
                            ? 'fogDrift 240s linear infinite'
                            : 'fogDrift 180s linear infinite, fogFloat 40s ease-in-out infinite';
                    }

                    // Fog haze - pure CSS (skip on low performance)
                    if (fogHaze && this.performanceMode !== 'low') {
                        fogHaze.style.animation = 'hazeBreath 20s ease-in-out infinite';
                    }

                    // Vignette breathing - pure CSS
                    if (vignette) {
                        vignette.style.animation = 'vignetteBreath 8s ease-in-out infinite';
                    }

                    // Scanlines - pure CSS
                    if (scanlines) {
                        (scanlines as HTMLElement).style.animation = 'scanlineMove 15s linear infinite';
                    }

                    // Static noise - pure CSS (skip on low performance)
                    if (staticNoise && this.performanceMode !== 'low') {
                        staticNoise.style.animation = 'staticFlicker 0.15s steps(4) infinite';
                    }
                }

                // ============================================
                // BACKGROUND MUSIC (AUTOPLAY BYPASS)
                // ============================================
                setupBackgroundMusic() {
                    this.bgMusic = document.getElementById('background-music') as HTMLAudioElement | null;
                    if (!this.bgMusic) return;

                    this.bgMusic.volume = 0.4;

                    // Do NOT autoplay on any interaction
                    // Music will only play when user clicks the audio toggle button

                    // Try when user returns to tab (only if music was already playing)
                    document.addEventListener('visibilitychange', () => {
                        if (document.visibilityState === 'visible' && this.musicStarted && this.audioEnabled) {
                            this.tryPlayMusic();
                        }
                    });
                }

                tryPlayMusic() {
                    if (!this.bgMusic) return;

                    const playPromise = this.bgMusic.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            this.musicStarted = true;
                            this.audioEnabled = true;
                            document.getElementById('audio-toggle')?.classList.remove('muted');
                            // Add state-changing class for animation
                            const toggle = document.getElementById('audio-toggle');
                            toggle?.classList.add('state-changing');
                            setTimeout(() => toggle?.classList.remove('state-changing'), 500);
                        }).catch(() => {
                            // Autoplay prevented - user must click button to start music
                            console.log('Autoplay prevented - click play button to start music');
                        });
                    }
                }

                // ============================================
                // MOTION ANIMATIONS (now CSS-based for performance)
                // ============================================
                // Background animations moved to CSS keyframes for GPU acceleration
                // See enableCSSAnimations() method and global.css

                setupPageLoad() {
                    // Re-cache elements on page load (for Astro navigation)
                    this.cacheElements();

                    // Simple instant fade - "old web" feel
                    const pageContent = this.cachedElements.pageContent;
                    if (pageContent) {
                        if (this.prefersReducedMotion) {
                            pageContent.style.opacity = '1';
                        } else {
                            animate(
                                pageContent,
                                { opacity: [0, 1] } as any,
                                { duration: 0.15, easing: 'ease-out' } as any
                            );
                        }
                    }

                    // Only setup breathing effects if motion is allowed
                    if (this.prefersReducedMotion) return;

                    // Skip symbol breathing on low performance
                    if (this.performanceMode !== 'low') {
                        // Symbol breathing effects (header) - using CSS animation instead
                        const headerSymbol = this.cachedElements.headerSymbol;
                        if (headerSymbol) {
                            (headerSymbol as HTMLElement).style.animation = 'symbolBreath 4s ease-in-out infinite';
                        }

                        // Home symbol breathing
                        const bigSymbol = this.cachedElements.bigSymbol;
                        if (bigSymbol) {
                            (bigSymbol as HTMLElement).style.animation = 'symbolBreath 4s ease-in-out infinite';
                        }
                    }

                    // Skip parallax on low performance
                    if (this.performanceMode === 'high') {
                        const bloodLayerEl = this.cachedElements.bloodLayer;
                        if (bloodLayerEl) {
                            scroll(
                                animate(bloodLayerEl, {
                                    y: [0, -50]
                                } as any) as any,
                                {
                                    target: document.body,
                                    offset: ['start start', 'end end']
                                } as any
                            );
                        }
                    }
                }

                // ============================================
                // AUDIO SYSTEM
                // ============================================
                setupAudioToggle() {
                    const toggle = document.getElementById('audio-toggle');
                    if (!toggle) return;

                    toggle.addEventListener('click', () => {
                        if (!this.audioInitialized) {
                            // First click: initialize audio AND start music
                            this.initAudio();
                            this.tryPlayMusic(); // Start music immediately on first click
                        } else {
                            this.toggleAudio();
                        }
                    });
                }

                initAudio() {
                    try {
                        this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
                        this.audioInitialized = true;
                        this.audioEnabled = true;
                        document.getElementById('audio-toggle')?.classList.remove('muted');
                        this.updateAudioIndicatorText();
                        this.startAmbientDrone();
                    } catch (e) {
                        console.log('Audio not supported');
                    }
                }

                toggleAudio() {
                    this.audioEnabled = !this.audioEnabled;
                    const toggle = document.getElementById('audio-toggle');

                    // Add state-changing animation class
                    toggle?.classList.add('state-changing');
                    setTimeout(() => toggle?.classList.remove('state-changing'), 500);

                    if (this.audioEnabled) {
                        toggle?.classList.remove('muted');
                        if (this.bgMusic) {
                            this.bgMusic.play();
                            this.musicStarted = true;
                        }
                        this.startAmbientDrone();
                    } else {
                        toggle?.classList.add('muted');
                        if (this.bgMusic) {
                            this.bgMusic.pause();
                        }
                        this.stopAllAudio();
                    }
                    this.updateAudioIndicatorText();
                }

                updateAudioIndicatorText() {
                    const toggle = document.getElementById('audio-toggle');
                    const label = toggle?.querySelector('.label');
                    if (!label) return;

                    label.textContent = this.audioEnabled ? 'PAUSE' : 'PLAY';
                }

                startAmbientDrone() {
                    if (!this.audioContext || !this.audioEnabled) return;

                    // Deep bass drone
                    const bassOsc = this.audioContext.createOscillator();
                    const bassGain = this.audioContext.createGain();
                    bassOsc.type = 'sine';
                    bassOsc.frequency.setValueAtTime(40, this.audioContext.currentTime);
                    bassGain.gain.setValueAtTime(0.08, this.audioContext.currentTime);
                    bassOsc.connect(bassGain);
                    bassGain.connect(this.audioContext.destination);
                    bassOsc.start();
                    this.oscillators.push(bassOsc);
                    this.gainNodes.push(bassGain);

                    // Eerie high frequency
                    const highOsc = this.audioContext.createOscillator();
                    const highGain = this.audioContext.createGain();
                    highOsc.type = 'sine';
                    highOsc.frequency.setValueAtTime(880, this.audioContext.currentTime);
                    highGain.gain.setValueAtTime(0.015, this.audioContext.currentTime);
                    highOsc.connect(highGain);
                    highGain.connect(this.audioContext.destination);
                    highOsc.start();
                    this.oscillators.push(highOsc);
                    this.gainNodes.push(highGain);

                    this.modulateAmbient();
                }

                modulateAmbient() {
                    if (!this.audioEnabled || !this.audioContext) return;

                    const now = this.audioContext.currentTime;

                    this.oscillators.forEach((osc, i) => {
                        const baseFreq = i === 0 ? 40 : 880;
                        const variation = (Math.random() - 0.5) * (i === 0 ? 10 : 100);
                        osc.frequency.setTargetAtTime(baseFreq + variation, now, 2);
                    });

                    this.gainNodes.forEach((gain, i) => {
                        const baseGain = i === 0 ? 0.08 : 0.015;
                        const variation = (Math.random() - 0.5) * 0.03;
                        gain.gain.setTargetAtTime(Math.max(0, baseGain + variation), now, 1);
                    });

                    setTimeout(() => this.modulateAmbient(), 3000 + Math.random() * 4000);
                }

                stopAllAudio() {
                    this.oscillators.forEach(osc => {
                        try { osc.stop(); } catch(e) {}
                    });
                    this.oscillators = [];
                    this.gainNodes = [];
                }

                playJumpscareSound() {
                    if (!this.audioContext || !this.audioEnabled) return;

                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();

                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, this.audioContext.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.3);

                    gain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);

                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    osc.start();
                    osc.stop(this.audioContext.currentTime + 0.4);
                }

                playWhisperSound() {
                    if (!this.audioContext || !this.audioEnabled) return;

                    const bufferSize = this.audioContext.sampleRate * 0.5;
                    const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    const data = buffer.getChannelData(0);

                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = (Math.random() * 2 - 1) * 0.1;
                    }

                    const source = this.audioContext.createBufferSource();
                    source.buffer = buffer;

                    const filter = this.audioContext.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.setValueAtTime(1000, this.audioContext.currentTime);
                    filter.Q.setValueAtTime(5, this.audioContext.currentTime);

                    const gain = this.audioContext.createGain();
                    gain.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gain.gain.linearRampToValueAtTime(0.1, this.audioContext.currentTime + 0.1);
                    gain.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 0.5);

                    source.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.audioContext.destination);
                    source.start();
                }

                playGlitchSound() {
                    if (!this.audioContext || !this.audioEnabled) return;

                    // Short digital glitch
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();

                    osc.type = 'square';
                    osc.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.1);

                    gain.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);

                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    osc.start();
                    osc.stop(this.audioContext.currentTime + 0.15);
                }

                // ============================================
                // GLITCH EFFECTS (now handled by main loop)
                // ============================================
                setupGlitchEffects() {
                    // Glitch effects are now scheduled by startMainLoop
                    // using cached elements for better performance
                }

                triggerStaticBurst() {
                    const staticEl = this.cachedElements.staticNoise;
                    if (!staticEl) return;

                    staticEl.classList.add('active');
                    animate(
                        staticEl,
                        { opacity: [0.5, 0.03] } as any,
                        { duration: 0.5, easing: 'ease-out' } as any
                    );
                    setTimeout(() => staticEl.classList.remove('active'), 500);
                }

                triggerHeavyGlitch() {
                    const body = document.body;

                    // Simplified for performance - transform only on low/medium
                    if (this.performanceMode === 'low') {
                        animate(
                            body,
                            { x: [-3, 3, -2, 2, 0] } as any,
                            { duration: 0.4, easing: 'ease-out' } as any
                        );
                    } else if (this.performanceMode === 'medium') {
                        animate(
                            body,
                            {
                                x: [-5, 5, -3, 3, 0],
                                skewX: [-1, 1, 0]
                            } as any,
                            { duration: 0.4, easing: 'ease-out' } as any
                        );
                        this.triggerStaticBurst();
                    } else {
                        animate(
                            body,
                            {
                                x: [-5, 5, -3, 3, 0],
                                skewX: [-2, 2, 0],
                                filter: [
                                    'none',
                                    'hue-rotate(90deg)',
                                    'saturate(2) contrast(1.5)',
                                    'invert(1)',
                                    'none'
                                ]
                            } as any,
                            { duration: 0.4, easing: 'ease-out' } as any
                        );
                        this.triggerStaticBurst();
                    }
                }

                // ============================================
                // WHISPERS (now handled by main loop with pooled elements)
                // ============================================
                setupWhispers() {
                    // Whispers are now scheduled by startMainLoop using pooled elements
                    // This method is kept for compatibility but the actual scheduling
                    // happens in the unified main loop for better performance
                }

                // ============================================
                // JUMPSCARES
                // ============================================
                setupJumpscares() {
                    // Throttled scroll handler for jumpscares
                    let scrollTimeout: number | null = null;

                    document.addEventListener('scroll', () => {
                        if (scrollTimeout) return;

                        scrollTimeout = window.setTimeout(() => {
                            const rand = Math.random();
                            if (rand < 0.008 && !this.jumpscareTriggered) {
                                if (rand < 0.002) {
                                    // 25% of triggers are full jumpscares
                                    this.triggerFullJumpscare();
                                    this.jumpscareTriggered = true;
                                    setTimeout(() => { this.jumpscareTriggered = false; }, 30000);
                                } else {
                                    this.triggerMiniScare();
                                }
                            }
                            scrollTimeout = null;
                        }, 100);
                    }, { passive: true });
                }

                triggerMiniScare() {
                    if (this.jumpscareTriggered) return;
                    this.jumpscareTriggered = true;

                    this.triggerHeavyGlitch();
                    this.playJumpscareSound();

                    setTimeout(() => {
                        this.jumpscareTriggered = false;
                    }, 30000);
                }

                triggerFullJumpscare() {
                    const overlay = this.cachedElements.jumpscareOverlay;
                    const content = this.cachedElements.scareContent;
                    if (!overlay || !content) return;

                    content.innerHTML = this.scareSymbols[Math.floor(Math.random() * this.scareSymbols.length)];
                    overlay.classList.add('active');
                    this.playJumpscareSound();
                    this.triggerStaticBurst();

                    // Simplified shake animation
                    animate(
                        content,
                        {
                            x: [-8, 8, -4, 4, 0],
                            y: [4, -4, -8, 4, 0],
                            rotate: [-2, 2, -1, 1, 0]
                        } as any,
                        { duration: 0.2, repeat: 2 } as any
                    );

                    // Background flash
                    animate(
                        overlay,
                        { background: ['#ffffff', '#cc0000', '#000000'] } as any,
                        { duration: 0.4, easing: 'ease-out' } as any
                    );

                    setTimeout(() => {
                        overlay.classList.remove('active');
                    }, 400);
                }

                // ============================================
                // SCROLL EFFECTS
                // ============================================
                setupScrollEffects() {
                    let lastScroll = 0;
                    let scrollVelocity = 0;
                    let scrollRaf: number | null = null;

                    // Optimized scroll handler using requestAnimationFrame
                    window.addEventListener('scroll', () => {
                        if (scrollRaf) return;

                        scrollRaf = requestAnimationFrame(() => {
                            const currentScroll = window.scrollY;
                            scrollVelocity = Math.abs(currentScroll - lastScroll);
                            lastScroll = currentScroll;

                            if (scrollVelocity > 100) {
                                this.triggerStaticBurst();
                            }

                            if (scrollVelocity > 200 && Math.random() < 0.15 && !this.jumpscareTriggered) {
                                // 40% chance of full jumpscare, 60% chance of mini
                                if (Math.random() < 0.4) {
                                    this.triggerFullJumpscare();
                                    this.jumpscareTriggered = true;
                                    setTimeout(() => { this.jumpscareTriggered = false; }, 30000);
                                } else {
                                    this.triggerMiniScare();
                                }
                            }

                            scrollRaf = null;
                        });
                    }, { passive: true });
                }

                // ============================================
                // UNIFIED MAIN LOOP (replaces multiple timers)
                // ============================================
                startMainLoop() {
                    // Throttled interaction tracking
                    let interactionTimeout: number | null = null;
                    const updateInteraction = () => {
                        if (interactionTimeout) return;
                        interactionTimeout = window.setTimeout(() => {
                            this.lastInteraction = Date.now();
                            interactionTimeout = null;
                        }, 500);
                    };

                    ['mousemove', 'keydown', 'scroll', 'click'].forEach(event => {
                        document.addEventListener(event, updateInteraction, { passive: true });
                    });

                    // Performance-adjusted intervals (in seconds)
                    const intervals = this.performanceMode === 'low'
                        ? { tick: 8000, whisper: 40000, glitch: 15000 }
                        : this.performanceMode === 'medium'
                        ? { tick: 6000, whisper: 25000, glitch: 8000 }
                        : { tick: 4000, whisper: 15000, glitch: 5000 };

                    // Schedule whispers with requestIdleCallback when available
                    const scheduleWhisper = () => {
                        const delay = intervals.whisper + Math.random() * intervals.whisper;
                        setTimeout(() => {
                            if ('requestIdleCallback' in window) {
                                requestIdleCallback(() => this.showPooledWhisper(), { timeout: 5000 });
                            } else {
                                this.showPooledWhisper();
                            }
                            scheduleWhisper();
                        }, delay);
                    };
                    scheduleWhisper();

                    // Schedule glitch effects
                    if (this.performanceMode !== 'low') {
                        const scheduleGlitch = () => {
                            const delay = intervals.glitch + Math.random() * intervals.glitch * 2;
                            setTimeout(() => {
                                this.triggerGlitchEffect();
                                scheduleGlitch();
                            }, delay);
                        };
                        setTimeout(scheduleGlitch, intervals.glitch);
                    }

                    // Main tick loop - consolidated random events
                    this.tickCounter = 0;
                    setInterval(() => {
                        this.tickCounter++;
                        this.mainLoopTick();
                    }, intervals.tick);
                }

                mainLoopTick() {
                    const tick = this.tickCounter;
                    const idleTime = Date.now() - this.lastInteraction;
                    const mode = this.performanceMode;

                    // Idle detection (every 2 ticks ~ 8-16s)
                    if (tick % 2 === 0) {
                        // Idle whisper
                        if (idleTime > 30000) {
                            const prob = mode === 'low' ? 0.05 : mode === 'medium' ? 0.1 : 0.15;
                            if (Math.random() < prob) {
                                this.showPooledWhisper();
                            }
                        }

                        // Idle jumpscare
                        if (idleTime > 60000 && !this.jumpscareTriggered) {
                            const prob = mode === 'low' ? 0.02 : mode === 'medium' ? 0.05 : 0.08;
                            if (Math.random() < prob) {
                                this.triggerFullJumpscare();
                                this.jumpscareTriggered = true;
                                setTimeout(() => { this.jumpscareTriggered = false; }, 30000);
                            }
                        }
                    }

                    // Screen flicker (every 2 ticks) - skip on low
                    if (mode !== 'low' && tick % 2 === 0 && Math.random() < 0.08) {
                        this.screenFlicker();
                    }

                    // Text distortion (every 3 ticks) - use requestIdleCallback
                    if (tick % 3 === 0 && Math.random() < (mode === 'low' ? 0.04 : 0.12)) {
                        if ('requestIdleCallback' in window) {
                            requestIdleCallback(() => this.distortRandomText(), { timeout: 2000 });
                        } else {
                            this.distortRandomText();
                        }
                    }

                    // Skip these on low performance
                    if (mode === 'low') {
                        if (tick >= 100) this.tickCounter = 0;
                        return;
                    }

                    // Screen invert (every 5 ticks)
                    if (tick % 5 === 0 && Math.random() < 0.04) {
                        this.triggerScreenInvert();
                    }

                    // Split screen (every 6 ticks)
                    if (mode === 'high' && tick % 6 === 0 && Math.random() < 0.06) {
                        this.triggerSplitScreen();
                    }

                    // Vignette close (every 7 ticks)
                    if (tick % 7 === 0 && Math.random() < 0.05) {
                        this.triggerVignetteClose();
                    }

                    // Blood rain (every 10 ticks) - high performance only
                    if (mode === 'high' && tick % 10 === 0 && Math.random() < 0.03) {
                        this.triggerBloodRain();
                    }

                    // Reset counter to prevent overflow
                    if (tick >= 420) this.tickCounter = 0;
                }

                triggerGlitchEffect() {
                    const elements = this.cachedElements.glitchTexts;
                    if (elements.length === 0) return;

                    const el = elements[Math.floor(Math.random() * elements.length)];

                    animate(
                        el,
                        {
                            x: [-2, 2, -2, 0],
                            y: [1, -1, 1, 0],
                            textShadow: [
                                'inherit',
                                '-3px 0 #cc0000, 3px 0 #990000',
                                '3px 0 #cc0000, -3px 0 #990000',
                                'inherit'
                            ]
                        } as any,
                        { duration: 0.3, easing: 'ease-out' } as any
                    );
                }

                // Pooled whisper system - reuses DOM elements
                showPooledWhisper() {
                    if (this.whisperPool.length === 0) return;

                    const text = this.whispers[Math.floor(Math.random() * this.whispers.length)];
                    const whisper = this.getPooledWhisper();

                    whisper.textContent = text;
                    whisper.style.left = (10 + Math.random() * 70) + '%';
                    whisper.style.top = (10 + Math.random() * 70) + '%';
                    whisper.style.transform = `rotate(${(Math.random() - 0.5) * 20}deg)`;
                    whisper.style.display = 'block';

                    this.playWhisperSound();
                    this.whisperCount++;

                    // Use simpler animation for better performance
                    animate(
                        whisper,
                        { opacity: [0, 0.4, 0.3, 0] } as any,
                        { duration: 4, easing: 'ease-out' } as any
                    );

                    setTimeout(() => {
                        whisper.style.display = 'none';
                        this.whisperCount = Math.max(0, this.whisperCount - 1);
                    }, 4000);
                }

                showIdleWhisper() {
                    // Delegate to pooled version
                    this.showPooledWhisper();
                }

                // ============================================
                // INTERACTIVE ELEMENTS
                // ============================================
                setupInteractiveElements() {
                    const main = this.cachedElements.main;
                    if (!main) return;

                    // Reduced probabilities on low performance
                    const probs = this.performanceMode === 'low'
                        ? { text: 0.02, card: 0.05, header: 0.1 }
                        : this.performanceMode === 'medium'
                        ? { text: 0.05, card: 0.1, header: 0.2 }
                        : { text: 0.08, card: 0.15, header: 0.25 };

                    // Event delegation with throttling
                    let hoverThrottle = false;
                    main.addEventListener('mouseover', (e) => {
                        if (hoverThrottle) return;
                        hoverThrottle = true;
                        setTimeout(() => { hoverThrottle = false; }, 200);

                        const target = e.target as HTMLElement;

                        if (target.matches('p, li') && Math.random() < probs.text) {
                            this.triggerTextCorruption(target);
                        }

                        if (target.matches('.article-card') || target.closest('.article-card')) {
                            const card = target.matches('.article-card') ? target : target.closest('.article-card') as HTMLElement;
                            if (card && Math.random() < probs.card) {
                                this.triggerCardGlitch(card);
                            }
                        }
                    }, { passive: true });

                    // Click handler with reduced frequency
                    main.addEventListener('click', (e) => {
                        const target = e.target as HTMLElement;
                        if (target.matches('h2, h3') && Math.random() < probs.header) {
                            this.triggerHeaderDistortion(target);
                        }
                    }, { passive: true });
                }

                triggerTextCorruption(element: HTMLElement) {
                    const originalText = element.textContent || '';
                    const glitchChars = ['‚ñà', '‚ñì', '‚ñí', '‚ñë', '‚ò†', '‚Ä†', '‚ò©', '‚õß'];

                    // Randomly corrupt some characters
                    let corruptedText = originalText.split('').map(char => {
                        return Math.random() < 0.15 ? glitchChars[Math.floor(Math.random() * glitchChars.length)] : char;
                    }).join('');

                    element.textContent = corruptedText;
                    this.playWhisperSound();

                    animate(
                        element,
                        {
                            color: ['inherit', '#cc0000', '#990000', 'inherit'],
                            textShadow: ['none', '0 0 10px rgba(204, 0, 0, 0.8)', '0 0 15px rgba(153, 0, 0, 0.6)', 'none']
                        } as any,
                        { duration: 0.8, easing: 'ease-in-out' } as any
                    );

                    // Restore original text
                    setTimeout(() => {
                        element.textContent = originalText;
                    }, 800);
                }

                triggerCardGlitch(card: HTMLElement) {
                    // Simplified - transform only for GPU acceleration
                    if (this.performanceMode === 'low') {
                        animate(
                            card,
                            { x: [-2, 2, 0] } as any,
                            { duration: 0.3, easing: 'ease-out' } as any
                        );
                    } else {
                        animate(
                            card,
                            {
                                x: [-3, 3, -2, 2, 0],
                                y: [2, -2, 1, -1, 0],
                                rotate: [-1, 1, -0.5, 0.5, 0],
                                opacity: [1, 0.8, 1, 0.9, 1]
                            } as any,
                            { duration: 0.4, easing: 'ease-out' } as any
                        );
                        this.playGlitchSound();
                    }
                }

                triggerHeaderDistortion(header: HTMLElement) {
                    // Simplified - transform + text-shadow only
                    if (this.performanceMode === 'low') {
                        animate(
                            header,
                            { x: [-3, 3, -2, 2, 0] } as any,
                            { duration: 0.4, easing: 'ease-out' } as any
                        );
                    } else {
                        animate(
                            header,
                            {
                                x: [-4, 4, -2, 2, 0],
                                scale: [1, 1.01, 0.99, 1],
                                textShadow: [
                                    'inherit',
                                    '4px 0 #cc0000, -4px 0 #990000',
                                    '0 4px #cc0000, 0 -4px #990000',
                                    'inherit'
                                ]
                            } as any,
                            { duration: 0.5, easing: [0.4, 0, 0.2, 1] } as any
                        );
                        this.triggerStaticBurst();
                    }
                }

                // ============================================
                // KEYBOARD EASTER EGGS
                // ============================================
                setupKeyboardEasterEggs() {
                    const keySequence: string[] = [];
                    const maxSequenceLength = 10;

                    document.addEventListener('keydown', (e) => {
                        keySequence.push(e.key.toLowerCase());
                        if (keySequence.length > maxSequenceLength) {
                            keySequence.shift();
                        }

                        // "pyramid" - Trigger full jumpscare
                        if (keySequence.slice(-7).join('') === 'pyramid') {
                            if (!this.jumpscareTriggered) {
                                this.triggerFullJumpscare();
                                this.jumpscareTriggered = true;
                                setTimeout(() => { this.jumpscareTriggered = false; }, 30000);
                            }
                            keySequence.length = 0;
                        }

                        // "maria" - Summon multiple whispers
                        if (keySequence.slice(-5).join('') === 'maria') {
                            for (let i = 0; i < 5; i++) {
                                setTimeout(() => this.showIdleWhisper(), i * 300);
                            }
                            keySequence.length = 0;
                        }

                        // "666" - Heavy glitch storm
                        if (keySequence.slice(-3).join('') === '666') {
                            for (let i = 0; i < 3; i++) {
                                setTimeout(() => this.triggerHeavyGlitch(), i * 200);
                            }
                            keySequence.length = 0;
                        }

                        // "blood" - Red screen pulse
                        if (keySequence.slice(-5).join('') === 'blood') {
                            this.triggerBloodPulse();
                            keySequence.length = 0;
                        }
                    });
                }

                triggerBloodPulse() {
                    const bloodGlow = document.getElementById('blood-glow');
                    if (!bloodGlow) return;

                    animate(
                        bloodGlow,
                        {
                            opacity: [0.8, 1, 0.95, 1, 0.8],
                            filter: ['brightness(1)', 'brightness(2) saturate(2)', 'brightness(1.5)', 'brightness(2)', 'brightness(1)']
                        } as any,
                        { duration: 2, easing: 'ease-in-out' } as any
                    );

                    this.playJumpscareSound();
                }

                // ============================================
                // RANDOM EVENTS (now handled by mainLoopTick)
                // ============================================
                // All random events consolidated into startMainLoop/mainLoopTick
                // for better performance with adaptive timing

                // GPU-accelerated visual effects - avoid expensive filters
                screenFlicker() {
                    const body = document.body;

                    // Use opacity instead of brightness filter (much cheaper)
                    animate(
                        body,
                        { opacity: [1, 0.3, 1, 0.5, 1] } as any,
                        { duration: 0.13, easing: 'steps(4)' } as any
                    );
                }

                triggerScreenInvert() {
                    // Skip on low performance - invert is expensive
                    if (this.performanceMode === 'low') return;

                    const body = document.body;

                    animate(
                        body,
                        {
                            filter: ['invert(0)', 'invert(1)', 'invert(1)', 'invert(0)']
                        } as any,
                        { duration: 0.3, easing: 'steps(3)' } as any
                    );
                }

                triggerSplitScreen() {
                    // Skip on low/medium - multiple filters are expensive
                    if (this.performanceMode !== 'high') return;

                    const body = document.body;

                    // Simplified - transform only with one filter
                    animate(
                        body,
                        {
                            x: [0, -15, 15, -8, 8, 0],
                            opacity: [1, 0.8, 0.9, 0.85, 0.95, 1]
                        } as any,
                        { duration: 0.5, easing: 'ease-out' } as any
                    );

                    this.triggerStaticBurst();
                }

                triggerVignetteClose() {
                    const vignette = this.cachedElements.vignette;
                    if (!vignette) return;

                    // Use opacity only (GPU accelerated)
                    animate(
                        vignette,
                        { opacity: [1, 1.5, 1.3, 1] } as any,
                        { duration: 2, easing: 'ease-in-out' } as any
                    );
                }

                triggerBloodRain() {
                    // Skip on low/medium - complex effect
                    if (this.performanceMode !== 'high') return;

                    const bloodGlow = this.cachedElements.bloodGlow;
                    if (!bloodGlow) return;

                    // Simplified - transform + opacity only
                    animate(
                        bloodGlow,
                        {
                            opacity: [0.8, 1, 0.9, 1, 0.8],
                            y: [0, -15, -8, -12, 0]
                        } as any,
                        { duration: 3, easing: 'ease-in-out' } as any
                    );
                }

                distortRandomText() {
                    // Use cached paragraphs for better performance
                    const paragraphs = this.getParagraphs();
                    if (paragraphs.length === 0) return;

                    const p = paragraphs[Math.floor(Math.random() * paragraphs.length)];

                    // Simplified effects - prefer transform-only for GPU acceleration
                    const effectType = this.performanceMode === 'low'
                        ? 0  // Color only on low performance
                        : Math.floor(Math.random() * 4);

                    switch(effectType) {
                        case 0: // Color shift (cheapest - no repaints)
                            animate(
                                p,
                                {
                                    color: ['inherit', '#990000', 'inherit'],
                                    textShadow: ['none', '0 0 10px rgba(153, 0, 0, 0.6)', 'none']
                                } as any,
                                { duration: 2, easing: 'ease-in-out' } as any
                            );
                            break;

                        case 1: // Transform only (GPU accelerated)
                            animate(
                                p,
                                {
                                    x: [-2, 2, -1, 1, 0],
                                    rotate: [0, 1, -1, 0.5, 0],
                                    textShadow: ['none', '2px 2px 8px rgba(153, 0, 0, 0.8)', 'none']
                                } as any,
                                { duration: 1.5, easing: 'ease-in-out' } as any
                            );
                            break;

                        case 2: // Scale (GPU accelerated, no blur)
                            animate(
                                p,
                                {
                                    scale: [1, 1.02, 0.98, 1],
                                    opacity: [1, 0.8, 0.9, 1],
                                    color: ['inherit', '#cc0000', '#990000', 'inherit']
                                } as any,
                                { duration: 1.8, easing: 'ease-in-out' } as any
                            );
                            break;

                        case 3: // Text shadow glitch (no filter)
                            animate(
                                p,
                                {
                                    x: [-1, 1, 0],
                                    color: ['inherit', '#ff0000', '#990000', 'inherit'],
                                    textShadow: [
                                        'none',
                                        '3px 0 #cc0000, -3px 0 #990000',
                                        '0 2px #cc0000, 0 -2px #990000',
                                        'none'
                                    ]
                                } as any,
                                { duration: 1.2, easing: [0.4, 0, 0.6, 1] } as any
                            );
                            break;
                    }

                    if (Math.random() < 0.3 && this.performanceMode !== 'low') {
                        this.playGlitchSound();
                    }
                }
            }

            // Single instance of horror engine
            let horrorEngine: BloodHorrorEngine | null = null;

            // Updates the active navigation link indicator during view transitions
            // Handles Astro's client-side navigation without page refresh
            function updateActiveNavLink() {
                // Normalize current path with trailing slash
                let currentPath = window.location.pathname;
                if (!currentPath.endsWith('/')) {
                    currentPath += '/';
                }

                // Update active class on all nav links
                const navLinks = document.querySelectorAll('nav a');
                navLinks.forEach(link => {
                    link.classList.remove('active');

                    // Check if link href matches current path
                    const linkHref = link.getAttribute('href');
                    if (linkHref === currentPath) {
                        link.classList.add('active');
                    }
                });
            }

            function initHorrorEngine() {
                if (!horrorEngine) {
                    horrorEngine = new BloodHorrorEngine();
                } else {
                    // On page swap, just reinitialize page-specific animations
                    horrorEngine.setupPageLoad();
                }
            }

            // Initialize on first load
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    initHorrorEngine();
                    updateActiveNavLink();
                });
            } else {
                initHorrorEngine();
                updateActiveNavLink();
            }

            // Reinitialize page content on Astro navigation
            document.addEventListener('astro:after-swap', () => {
                if (horrorEngine) {
                    horrorEngine.setupPageLoad();
                }
            });

            // Update active nav link on Astro page transitions
            document.addEventListener('astro:page-load', updateActiveNavLink);
        </script>
    </body>
</html>
