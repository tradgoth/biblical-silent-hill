---
import "../styles/global.css";
import { ViewTransitions } from 'astro:transitions';

const { title, subtitle, symbol } = Astro.props;
const base = import.meta.env.BASE_URL;

// Normalize current path for comparison
let currentPath = Astro.url.pathname;
// Ensure trailing slash
if (!currentPath.endsWith('/')) {
    currentPath += '/';
}

const navLinks = [
    { href: `${base}/`, label: "HOME" },
    { href: `${base}/new-testament/`, label: "NEW TESTAMENT" },
    { href: `${base}/old-testament/`, label: "OLD TESTAMENT" },
    { href: `${base}/lilith/`, label: "LILITH" },
    { href: `${base}/demonology/`, label: "DEMONOLOGY" },
    { href: `${base}/symbolism/`, label: "SYMBOLISM" },
    { href: `${base}/collective-unconscious/`, label: "UNCONSCIOUS" },
    { href: `${base}/lexicon/`, label: "LEXICON" },
];
---

<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>{title} | Silent Hill Biblical Themes</title>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Special+Elite&family=Share+Tech+Mono&display=swap" rel="stylesheet">
        <ViewTransitions />
    </head>
    <body>
        <!-- Background music -->
        <audio id="background-music" loop preload="auto" transition:persist="bgmusic">
            <source src={`${base}/fairy.mp3`} type="audio/mpeg">
        </audio>

        <!-- Blood & Horror atmosphere layers -->
        <div class="blood-layer" aria-hidden="true" id="blood-layer" transition:persist="blood"></div>
        <div class="blood-glow" aria-hidden="true" id="blood-glow" transition:persist="glow"></div>
        <div class="fog-layer" aria-hidden="true" id="fog-layer" transition:persist="fog"></div>
        <div class="fog-haze" aria-hidden="true" id="fog-haze" transition:persist="haze"></div>
        <div class="vignette" aria-hidden="true" id="vignette" transition:persist="vignette"></div>
        <div class="scanlines" aria-hidden="true" transition:persist="scanlines"></div>
        <div class="static-noise" id="static-noise" aria-hidden="true" transition:persist="static"></div>

        <!-- Jumpscare overlay -->
        <div class="jumpscare-overlay" id="jumpscare-overlay" transition:persist="jumpscare">
            <div class="scare-content" id="scare-content"></div>
        </div>

        <!-- Audio indicator -->
        <div class="audio-indicator muted" id="audio-toggle" transition:persist="audio-toggle">
            <span class="icon">â™ª</span>
        </div>

        <nav transition:persist="nav">
            <ul>
                {
                    navLinks.map((link) => (
                        <li>
                            <a
                                href={link.href}
                                class={currentPath === link.href ? "active" : ""}
                                data-text={link.label}
                            >
                                {link.label}
                            </a>
                        </li>
                    ))
                }
            </ul>
        </nav>

        {
            title !== "Silent Hill" && (
                <header>
                    <div class="symbol glitch-text">{symbol}</div>
                    <h1 class="glitch-text">{title}</h1>
                    <div class="subtitle">{subtitle}</div>
                    <div class="header-border"></div>
                </header>
            )
        }

        <div class="container page-content">
            <main>
                <slot />
            </main>
        </div>

        <footer>
            <div class="motto">â˜© IN STERQUILINIIS INVENITUR â˜©</div>
            <div class="translation">"In the dirt, it will be found"</div>
        </footer>

        <script>
            // @ts-ignore - Motion library types don't include all CSS properties
            import { animate, scroll } from "motion";

            // ============================================
            // DARK RED BLOOD HORROR ENGINE
            // Motion-powered animations
            // ============================================

            class BloodHorrorEngine {
                // Audio System Properties
                audioContext: AudioContext | null;
                audioEnabled: boolean;
                audioInitialized: boolean;
                oscillators: OscillatorNode[];
                gainNodes: GainNode[];
                bgMusic: HTMLAudioElement | null;
                musicStarted: boolean;

                // Horror Effect Properties
                lastInteraction: number;
                jumpscareTriggered: boolean;
                whisperCount: number;
                maxWhispers: number;
                whispers: string[];
                scareSymbols: string[];

                // Accessibility
                prefersReducedMotion: boolean;

                constructor() {
                    this.audioContext = null;
                    this.audioEnabled = false;
                    this.audioInitialized = false;
                    this.oscillators = [];
                    this.gainNodes = [];
                    this.lastInteraction = Date.now();
                    this.jumpscareTriggered = false;
                    this.whisperCount = 0;
                    this.maxWhispers = 3;
                    this.bgMusic = null;
                    this.musicStarted = false;
                    this.prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

                    this.whispers = [
                        "The blood...",
                        "It never stops...",
                        "Can you see it?",
                        "The walls are bleeding",
                        "Silent Hill",
                        "In my restless dreams",
                        "I see that town",
                        "There was a hole here",
                        "It's gone now",
                        "Born from a wish",
                        "Forgive me",
                        "The darkness",
                        "Red pyramid",
                        "Behind you",
                        "Don't look",
                        "Turn back",
                        "Dead people don't write letters",
                        "Mary...",
                        "James...",
                        "You killed her",
                        "The monster",
                        "Something's wrong"
                    ];

                    this.scareSymbols = ['â˜ ', 'âœ', 'â˜©', 'â›§', 'â€ ', 'â˜ ', 'ðŸ’€', 'â›§'];

                    this.init();
                }

                init() {
                    this.setupBackgroundMusic();
                    this.setupAudioToggle();

                    if (!this.prefersReducedMotion) {
                        this.setupMotionAnimations();
                        this.setupGlitchEffects();
                        this.setupWhispers();
                        this.setupJumpscares();
                        this.setupScrollEffects();
                        this.setupIdleDetection();
                        this.setupRandomEvents();
                        this.setupInteractiveElements();
                        this.setupKeyboardEasterEggs();
                    }

                    this.setupPageLoad();
                }

                // ============================================
                // BACKGROUND MUSIC (AUTOPLAY BYPASS)
                // ============================================
                setupBackgroundMusic() {
                    this.bgMusic = document.getElementById('background-music') as HTMLAudioElement | null;
                    if (!this.bgMusic) return;

                    this.bgMusic.volume = 0.4;

                    // Do NOT autoplay on any interaction
                    // Music will only play when user clicks the audio toggle button

                    // Try when user returns to tab (only if music was already playing)
                    document.addEventListener('visibilitychange', () => {
                        if (document.visibilityState === 'visible' && this.musicStarted && this.audioEnabled) {
                            this.tryPlayMusic();
                        }
                    });
                }

                tryPlayMusic() {
                    if (!this.bgMusic) return;

                    const playPromise = this.bgMusic.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            this.musicStarted = true;
                            this.audioEnabled = true;
                            document.getElementById('audio-toggle')?.classList.remove('muted');
                            // Add state-changing class for animation
                            const toggle = document.getElementById('audio-toggle');
                            toggle?.classList.add('state-changing');
                            setTimeout(() => toggle?.classList.remove('state-changing'), 500);
                        }).catch(() => {
                            // Autoplay prevented - user must click button to start music
                            console.log('Autoplay prevented - click play button to start music');
                        });
                    }
                }

                // ============================================
                // MOTION ANIMATIONS
                // ============================================
                setupMotionAnimations() {
                    // Enhanced blood layer pulsing with more depth
                    const bloodLayer = document.getElementById('blood-layer');
                    if (bloodLayer) {
                        animate(
                            bloodLayer,
                            {
                                opacity: [1, 0.82, 0.95, 0.88, 1],
                                filter: [
                                    'brightness(1) contrast(1)',
                                    'brightness(1.08) contrast(1.05)',
                                    'brightness(0.95) contrast(1.02)',
                                    'brightness(1.05) contrast(1.03)',
                                    'brightness(1) contrast(1)'
                                ]
                            } as any,
                            {
                                duration: 12,
                                repeat: Infinity,
                                easing: 'ease-in-out'
                            } as any
                        );
                    }

                    // Enhanced blood glow flickering with irregular pattern
                    const bloodGlow = document.getElementById('blood-glow');
                    if (bloodGlow) {
                        animate(
                            bloodGlow,
                            {
                                opacity: [0.8, 0.55, 0.9, 0.65, 0.85, 0.7, 0.8],
                                filter: [
                                    'blur(0px)',
                                    'blur(1px)',
                                    'blur(0px)',
                                    'blur(2px)',
                                    'blur(0px)',
                                    'blur(1px)',
                                    'blur(0px)'
                                ]
                            } as any,
                            {
                                duration: 0.8,
                                repeat: Infinity,
                                easing: [0.45, 0.05, 0.55, 0.95]  // Custom easing for irregular flicker
                            } as any
                        );
                    }

                    // Enhanced fog drift with vertical movement
                    const fogLayer = document.getElementById('fog-layer');
                    if (fogLayer) {
                        // Horizontal drift
                        animate(
                            fogLayer,
                            {
                                x: ['0%', '-66.666%']
                            } as any,
                            {
                                duration: 180,  // Slower for more ominous effect
                                repeat: Infinity,
                                easing: 'linear'
                            } as any
                        );

                        // Add subtle vertical oscillation
                        animate(
                            fogLayer,
                            {
                                y: ['0%', '-2%', '0%', '2%', '0%']
                            } as any,
                            {
                                duration: 40,
                                repeat: Infinity,
                                easing: 'ease-in-out'
                            } as any
                        );
                    }

                    // Enhanced fog haze with opacity and blur variation
                    const fogHaze = document.getElementById('fog-haze');
                    if (fogHaze) {
                        animate(
                            fogHaze,
                            {
                                opacity: [0.5, 0.7, 0.4, 0.8, 0.5],
                                filter: [
                                    'blur(0px)',
                                    'blur(3px)',
                                    'blur(1px)',
                                    'blur(4px)',
                                    'blur(0px)'
                                ]
                            } as any,
                            {
                                duration: 20,
                                repeat: Infinity,
                                easing: 'ease-in-out'
                            } as any
                        );
                    }

                    // Enhanced vignette breathing with intensity variation
                    const vignette = document.getElementById('vignette');
                    if (vignette) {
                        animate(
                            vignette,
                            {
                                opacity: [1, 0.8, 0.95, 0.85, 1],
                                filter: [
                                    'brightness(1)',
                                    'brightness(0.95)',
                                    'brightness(1.02)',
                                    'brightness(0.98)',
                                    'brightness(1)'
                                ]
                            } as any,
                            {
                                duration: 8,
                                repeat: Infinity,
                                easing: 'ease-in-out'
                            } as any
                        );
                    }

                    // Scanlines movement - smoother, slower
                    const scanlines = document.querySelector('.scanlines');
                    if (scanlines) {
                        animate(
                            scanlines,
                            { y: [0, 8] } as any,
                            {
                                duration: 15,  // Slower for less distraction
                                repeat: Infinity,
                                easing: 'linear'
                            } as any
                        );
                    }

                    // Enhanced static noise flicker - more varied
                    const staticNoise = document.getElementById('static-noise');
                    if (staticNoise) {
                        animate(
                            staticNoise,
                            {
                                opacity: [0.03, 0.08, 0.02, 0.06, 0.04, 0.03],
                                filter: [
                                    'contrast(1)',
                                    'contrast(1.5)',
                                    'contrast(1)',
                                    'contrast(1.3)',
                                    'contrast(1.1)',
                                    'contrast(1)'
                                ]
                            } as any,
                            {
                                duration: 0.15,
                                repeat: Infinity,
                                easing: [0.4, 0, 0.6, 1]  // Sharp, irregular
                            } as any
                        );
                    }
                }

                setupPageLoad() {
                    // Simple instant fade - "old web" feel
                    const pageContent = document.querySelector('.page-content');
                    if (pageContent) {
                        if (this.prefersReducedMotion) {
                            (pageContent as HTMLElement).style.opacity = '1';
                        } else {
                            animate(
                                pageContent,
                                { opacity: [0, 1] } as any,
                                { duration: 0.15, easing: 'ease-out' } as any
                            );
                        }
                    }

                    // Only setup breathing effects if motion is allowed
                    if (this.prefersReducedMotion) return;

                    // Symbol breathing effects (header)
                    const headerSymbol = document.querySelector('header .symbol');
                    if (headerSymbol) {
                        animate(
                            headerSymbol,
                            {
                                textShadow: [
                                    '0 0 20px rgba(153, 0, 0, 0.4), 0 0 30px rgba(204, 0, 0, 0.5)',
                                    '0 0 30px rgba(153, 0, 0, 0.6), 0 0 50px rgba(204, 0, 0, 0.7)',
                                    '0 0 20px rgba(153, 0, 0, 0.4), 0 0 30px rgba(204, 0, 0, 0.5)'
                                ]
                            } as any,
                            { duration: 4, repeat: Infinity, easing: 'ease-in-out' } as any
                        );
                    }

                    // Home symbol breathing
                    const bigSymbol = document.querySelector('.home-intro .big-symbol');
                    if (bigSymbol) {
                        animate(
                            bigSymbol,
                            {
                                textShadow: [
                                    '0 0 30px rgba(153, 0, 0, 0.6), 0 0 60px rgba(204, 0, 0, 0.5)',
                                    '0 0 40px rgba(153, 0, 0, 0.8), 0 0 80px rgba(204, 0, 0, 0.7)',
                                    '0 0 30px rgba(153, 0, 0, 0.6), 0 0 60px rgba(204, 0, 0, 0.5)'
                                ]
                            } as any,
                            { duration: 4, repeat: Infinity, easing: 'ease-in-out' } as any
                        );
                    }

                    // Parallax scroll for blood layer (now works with absolute positioning)
                    const bloodLayerEl = document.getElementById('blood-layer');
                    if (bloodLayerEl) {
                        scroll(
                            animate(bloodLayerEl, {
                                y: [0, -50]  // Reduced range for subtler effect with absolute positioning
                            } as any) as any,
                            {
                                target: document.body,
                                offset: ['start start', 'end end']  // Animate across full scroll range
                            } as any
                        );
                    }
                }

                // ============================================
                // AUDIO SYSTEM
                // ============================================
                setupAudioToggle() {
                    const toggle = document.getElementById('audio-toggle');
                    if (!toggle) return;

                    toggle.addEventListener('click', () => {
                        if (!this.audioInitialized) {
                            // First click: initialize audio AND start music
                            this.initAudio();
                            this.tryPlayMusic(); // Start music immediately on first click
                        } else {
                            this.toggleAudio();
                        }
                    });
                }

                initAudio() {
                    try {
                        this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
                        this.audioInitialized = true;
                        this.audioEnabled = true;
                        document.getElementById('audio-toggle')?.classList.remove('muted');
                        this.updateAudioIndicatorText();
                        this.startAmbientDrone();
                    } catch (e) {
                        console.log('Audio not supported');
                    }
                }

                toggleAudio() {
                    this.audioEnabled = !this.audioEnabled;
                    const toggle = document.getElementById('audio-toggle');

                    // Add state-changing animation class
                    toggle?.classList.add('state-changing');
                    setTimeout(() => toggle?.classList.remove('state-changing'), 500);

                    if (this.audioEnabled) {
                        toggle?.classList.remove('muted');
                        if (this.bgMusic) {
                            this.bgMusic.play();
                            this.musicStarted = true;
                        }
                        this.startAmbientDrone();
                    } else {
                        toggle?.classList.add('muted');
                        if (this.bgMusic) {
                            this.bgMusic.pause();
                        }
                        this.stopAllAudio();
                    }
                    this.updateAudioIndicatorText();
                }

                updateAudioIndicatorText() {
                    const toggle = document.getElementById('audio-toggle');
                    const label = toggle?.querySelector('.label');
                    if (!label) return;

                    label.textContent = this.audioEnabled ? 'PAUSE' : 'PLAY';
                }

                startAmbientDrone() {
                    if (!this.audioContext || !this.audioEnabled) return;

                    // Deep bass drone
                    const bassOsc = this.audioContext.createOscillator();
                    const bassGain = this.audioContext.createGain();
                    bassOsc.type = 'sine';
                    bassOsc.frequency.setValueAtTime(40, this.audioContext.currentTime);
                    bassGain.gain.setValueAtTime(0.08, this.audioContext.currentTime);
                    bassOsc.connect(bassGain);
                    bassGain.connect(this.audioContext.destination);
                    bassOsc.start();
                    this.oscillators.push(bassOsc);
                    this.gainNodes.push(bassGain);

                    // Eerie high frequency
                    const highOsc = this.audioContext.createOscillator();
                    const highGain = this.audioContext.createGain();
                    highOsc.type = 'sine';
                    highOsc.frequency.setValueAtTime(880, this.audioContext.currentTime);
                    highGain.gain.setValueAtTime(0.015, this.audioContext.currentTime);
                    highOsc.connect(highGain);
                    highGain.connect(this.audioContext.destination);
                    highOsc.start();
                    this.oscillators.push(highOsc);
                    this.gainNodes.push(highGain);

                    this.modulateAmbient();
                }

                modulateAmbient() {
                    if (!this.audioEnabled || !this.audioContext) return;

                    const now = this.audioContext.currentTime;

                    this.oscillators.forEach((osc, i) => {
                        const baseFreq = i === 0 ? 40 : 880;
                        const variation = (Math.random() - 0.5) * (i === 0 ? 10 : 100);
                        osc.frequency.setTargetAtTime(baseFreq + variation, now, 2);
                    });

                    this.gainNodes.forEach((gain, i) => {
                        const baseGain = i === 0 ? 0.08 : 0.015;
                        const variation = (Math.random() - 0.5) * 0.03;
                        gain.gain.setTargetAtTime(Math.max(0, baseGain + variation), now, 1);
                    });

                    setTimeout(() => this.modulateAmbient(), 3000 + Math.random() * 4000);
                }

                stopAllAudio() {
                    this.oscillators.forEach(osc => {
                        try { osc.stop(); } catch(e) {}
                    });
                    this.oscillators = [];
                    this.gainNodes = [];
                }

                playJumpscareSound() {
                    if (!this.audioContext || !this.audioEnabled) return;

                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();

                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, this.audioContext.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.3);

                    gain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);

                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    osc.start();
                    osc.stop(this.audioContext.currentTime + 0.4);
                }

                playWhisperSound() {
                    if (!this.audioContext || !this.audioEnabled) return;

                    const bufferSize = this.audioContext.sampleRate * 0.5;
                    const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    const data = buffer.getChannelData(0);

                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = (Math.random() * 2 - 1) * 0.1;
                    }

                    const source = this.audioContext.createBufferSource();
                    source.buffer = buffer;

                    const filter = this.audioContext.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.setValueAtTime(1000, this.audioContext.currentTime);
                    filter.Q.setValueAtTime(5, this.audioContext.currentTime);

                    const gain = this.audioContext.createGain();
                    gain.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gain.gain.linearRampToValueAtTime(0.1, this.audioContext.currentTime + 0.1);
                    gain.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 0.5);

                    source.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.audioContext.destination);
                    source.start();
                }

                playGlitchSound() {
                    if (!this.audioContext || !this.audioEnabled) return;

                    // Short digital glitch
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();

                    osc.type = 'square';
                    osc.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.1);

                    gain.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);

                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    osc.start();
                    osc.stop(this.audioContext.currentTime + 0.15);
                }

                // ============================================
                // GLITCH EFFECTS
                // ============================================
                setupGlitchEffects() {
                    const triggerGlitch = () => {
                        const elements = document.querySelectorAll('.glitch-text');
                        if (elements.length === 0) return;

                        const el = elements[Math.floor(Math.random() * elements.length)];

                        animate(
                            el,
                            {
                                x: [-2, 2, -2, 0],
                                y: [1, -1, 1, 0],
                                textShadow: [
                                    'inherit',
                                    '-3px 0 #cc0000, 3px 0 #990000',
                                    '3px 0 #cc0000, -3px 0 #990000',
                                    'inherit'
                                ]
                            } as any,
                            { duration: 0.3, easing: 'ease-out' } as any
                        );

                        setTimeout(triggerGlitch, 3000 + Math.random() * 9000);
                    };

                    setTimeout(triggerGlitch, 3000);
                }

                triggerStaticBurst() {
                    const staticEl = document.getElementById('static-noise');
                    if (!staticEl) return;

                    staticEl.classList.add('active');
                    animate(
                        staticEl,
                        { opacity: [0.5, 0.03] } as any,
                        { duration: 0.5, easing: 'ease-out' } as any
                    );
                    setTimeout(() => staticEl.classList.remove('active'), 500);
                }

                triggerHeavyGlitch() {
                    const body = document.body;

                    animate(
                        body,
                        {
                            x: [-5, 5, -3, 3, 0],
                            skewX: [-2, 2, 0],
                            filter: [
                                'none',
                                'hue-rotate(90deg)',
                                'saturate(2) contrast(1.5)',
                                'invert(1)',
                                'none'
                            ]
                        } as any,
                        { duration: 0.4, easing: 'ease-out' } as any
                    );

                    this.triggerStaticBurst();
                }

                // ============================================
                // WHISPERS
                // ============================================
                setupWhispers() {
                    const showWhisper = () => {
                        if (this.whisperCount >= this.maxWhispers) {
                            this.whisperCount = 0;
                        }

                        const text = this.whispers[Math.floor(Math.random() * this.whispers.length)];
                        const whisper = document.createElement('div');
                        whisper.className = 'whisper';
                        whisper.textContent = text;
                        whisper.style.left = (10 + Math.random() * 70) + '%';
                        whisper.style.top = (10 + Math.random() * 70) + '%';
                        whisper.style.transform = `rotate(${(Math.random() - 0.5) * 20}deg)`;

                        document.body.appendChild(whisper);
                        this.playWhisperSound();
                        this.whisperCount++;

                        animate(
                            whisper,
                            {
                                opacity: [0, 0.4, 0.3, 0],
                                filter: ['blur(10px)', 'blur(2px)', 'blur(2px)', 'blur(10px)']
                            } as any,
                            { duration: 4, easing: 'ease-out' } as any
                        );

                        setTimeout(() => whisper.remove(), 4000);
                        setTimeout(showWhisper, 15000 + Math.random() * 25000);
                    };

                    setTimeout(showWhisper, 15000 + Math.random() * 20000);
                }

                // ============================================
                // JUMPSCARES
                // ============================================
                setupJumpscares() {
                    // Throttled scroll handler for jumpscares
                    let scrollTimeout: number | null = null;

                    document.addEventListener('scroll', () => {
                        if (scrollTimeout) return;

                        scrollTimeout = window.setTimeout(() => {
                            const rand = Math.random();
                            if (rand < 0.008 && !this.jumpscareTriggered) {
                                if (rand < 0.002) {
                                    // 25% of triggers are full jumpscares
                                    this.triggerFullJumpscare();
                                    this.jumpscareTriggered = true;
                                    setTimeout(() => { this.jumpscareTriggered = false; }, 30000);
                                } else {
                                    this.triggerMiniScare();
                                }
                            }
                            scrollTimeout = null;
                        }, 100);
                    }, { passive: true });
                }

                triggerMiniScare() {
                    if (this.jumpscareTriggered) return;
                    this.jumpscareTriggered = true;

                    this.triggerHeavyGlitch();
                    this.playJumpscareSound();

                    setTimeout(() => {
                        this.jumpscareTriggered = false;
                    }, 30000);
                }

                triggerFullJumpscare() {
                    const overlay = document.getElementById('jumpscare-overlay');
                    const content = document.getElementById('scare-content');
                    if (!overlay || !content) return;

                    content.innerHTML = this.scareSymbols[Math.floor(Math.random() * this.scareSymbols.length)];
                    overlay.classList.add('active');
                    this.playJumpscareSound();
                    this.triggerStaticBurst();

                    animate(
                        content,
                        {
                            x: [-10, 10, -5, 5, 0],
                            y: [5, -5, -10, 5, 0],
                            rotate: [-2, 2, -1, 1, 0]
                        } as any,
                        { duration: 0.2, repeat: 2 } as any
                    );

                    animate(
                        overlay,
                        {
                            background: ['#ffffff', '#cc0000', '#000000']
                        } as any,
                        { duration: 0.4, easing: 'ease-out' } as any
                    );

                    setTimeout(() => {
                        overlay.classList.remove('active');
                    }, 400);
                }

                // ============================================
                // SCROLL EFFECTS
                // ============================================
                setupScrollEffects() {
                    let lastScroll = 0;
                    let scrollVelocity = 0;
                    let scrollRaf: number | null = null;

                    // Optimized scroll handler using requestAnimationFrame
                    window.addEventListener('scroll', () => {
                        if (scrollRaf) return;

                        scrollRaf = requestAnimationFrame(() => {
                            const currentScroll = window.scrollY;
                            scrollVelocity = Math.abs(currentScroll - lastScroll);
                            lastScroll = currentScroll;

                            if (scrollVelocity > 100) {
                                this.triggerStaticBurst();
                            }

                            if (scrollVelocity > 200 && Math.random() < 0.15 && !this.jumpscareTriggered) {
                                // 40% chance of full jumpscare, 60% chance of mini
                                if (Math.random() < 0.4) {
                                    this.triggerFullJumpscare();
                                    this.jumpscareTriggered = true;
                                    setTimeout(() => { this.jumpscareTriggered = false; }, 30000);
                                } else {
                                    this.triggerMiniScare();
                                }
                            }

                            scrollRaf = null;
                        });
                    }, { passive: true });
                }

                // ============================================
                // IDLE DETECTION
                // ============================================
                setupIdleDetection() {
                    setInterval(() => {
                        const idleTime = Date.now() - this.lastInteraction;

                        if (idleTime > 30000 && Math.random() < 0.15) {
                            this.showIdleWhisper();
                        }

                        if (idleTime > 60000 && Math.random() < 0.08 && !this.jumpscareTriggered) {
                            this.triggerFullJumpscare();
                            this.jumpscareTriggered = true;
                            setTimeout(() => { this.jumpscareTriggered = false; }, 30000);
                        }
                    }, 5000);

                    // Throttled interaction tracking for better performance
                    let interactionTimeout: number | null = null;
                    const updateInteraction = () => {
                        if (interactionTimeout) return;
                        interactionTimeout = window.setTimeout(() => {
                            this.lastInteraction = Date.now();
                            interactionTimeout = null;
                        }, 500);
                    };

                    ['mousemove', 'keydown', 'scroll', 'click'].forEach(event => {
                        document.addEventListener(event, updateInteraction, { passive: true });
                    });
                }

                showIdleWhisper() {
                    const text = this.whispers[Math.floor(Math.random() * this.whispers.length)];
                    const whisper = document.createElement('div');
                    whisper.className = 'whisper';
                    whisper.textContent = text;
                    whisper.style.left = (20 + Math.random() * 60) + '%';
                    whisper.style.top = (20 + Math.random() * 60) + '%';

                    document.body.appendChild(whisper);
                    this.playWhisperSound();

                    animate(
                        whisper,
                        {
                            opacity: [0, 0.4, 0],
                            filter: ['blur(10px)', 'blur(2px)', 'blur(10px)']
                        } as any,
                        { duration: 4, easing: 'ease-out' } as any
                    );

                    setTimeout(() => whisper.remove(), 4000);
                }

                // ============================================
                // INTERACTIVE ELEMENTS
                // ============================================
                setupInteractiveElements() {
                    // Use event delegation for better performance
                    const main = document.querySelector('main');
                    if (!main) return;

                    // Single mouseover event listener using event delegation
                    main.addEventListener('mouseover', (e) => {
                        const target = e.target as HTMLElement;

                        // Check if target is a paragraph or list item
                        if (target.matches('p, li')) {
                            if (Math.random() < 0.08) {
                                this.triggerTextCorruption(target);
                            }
                        }

                        // Check if target is an article card
                        if (target.matches('.article-card') || target.closest('.article-card')) {
                            const card = target.matches('.article-card') ? target : target.closest('.article-card') as HTMLElement;
                            if (card && Math.random() < 0.15) {
                                this.triggerCardGlitch(card);
                            }
                        }
                    }, { passive: true });

                    // Single click event listener using event delegation
                    main.addEventListener('click', (e) => {
                        const target = e.target as HTMLElement;

                        // Check if target is a header
                        if (target.matches('h2, h3')) {
                            if (Math.random() < 0.25) {
                                this.triggerHeaderDistortion(target);
                            }
                        }
                    }, { passive: true });
                }

                triggerTextCorruption(element: HTMLElement) {
                    const originalText = element.textContent || '';
                    const glitchChars = ['â–ˆ', 'â–“', 'â–’', 'â–‘', 'â˜ ', 'â€ ', 'â˜©', 'â›§'];

                    // Randomly corrupt some characters
                    let corruptedText = originalText.split('').map(char => {
                        return Math.random() < 0.15 ? glitchChars[Math.floor(Math.random() * glitchChars.length)] : char;
                    }).join('');

                    element.textContent = corruptedText;
                    this.playWhisperSound();

                    animate(
                        element,
                        {
                            color: ['inherit', '#cc0000', '#990000', 'inherit'],
                            textShadow: ['none', '0 0 10px rgba(204, 0, 0, 0.8)', '0 0 15px rgba(153, 0, 0, 0.6)', 'none']
                        } as any,
                        { duration: 0.8, easing: 'ease-in-out' } as any
                    );

                    // Restore original text
                    setTimeout(() => {
                        element.textContent = originalText;
                    }, 800);
                }

                triggerCardGlitch(card: HTMLElement) {
                    animate(
                        card,
                        {
                            x: [-3, 3, -2, 2, 0],
                            y: [2, -2, 1, -1, 0],
                            rotate: [-1, 1, -0.5, 0.5, 0],
                            filter: [
                                'brightness(1)',
                                'brightness(0.7) saturate(2)',
                                'brightness(1.3) hue-rotate(15deg)',
                                'brightness(0.9)',
                                'brightness(1)'
                            ]
                        } as any,
                        { duration: 0.4, easing: 'ease-out' } as any
                    );

                    this.playGlitchSound();
                }

                triggerHeaderDistortion(header: HTMLElement) {
                    animate(
                        header,
                        {
                            scaleX: [1, 0.98, 1.03, 0.99, 1],
                            scaleY: [1, 1.02, 0.97, 1.01, 1],
                            x: [-5, 5, -3, 3, 0],
                            textShadow: [
                                'inherit',
                                '5px 0 #cc0000, -5px 0 #990000',
                                '0 5px #cc0000, 0 -5px #990000',
                                '3px 3px #cc0000, -3px -3px #990000',
                                'inherit'
                            ]
                        } as any,
                        { duration: 0.5, easing: [0.4, 0, 0.2, 1] } as any
                    );

                    this.triggerStaticBurst();
                }

                // ============================================
                // KEYBOARD EASTER EGGS
                // ============================================
                setupKeyboardEasterEggs() {
                    const keySequence: string[] = [];
                    const maxSequenceLength = 10;

                    document.addEventListener('keydown', (e) => {
                        keySequence.push(e.key.toLowerCase());
                        if (keySequence.length > maxSequenceLength) {
                            keySequence.shift();
                        }

                        // "pyramid" - Trigger full jumpscare
                        if (keySequence.slice(-7).join('') === 'pyramid') {
                            if (!this.jumpscareTriggered) {
                                this.triggerFullJumpscare();
                                this.jumpscareTriggered = true;
                                setTimeout(() => { this.jumpscareTriggered = false; }, 30000);
                            }
                            keySequence.length = 0;
                        }

                        // "maria" - Summon multiple whispers
                        if (keySequence.slice(-5).join('') === 'maria') {
                            for (let i = 0; i < 5; i++) {
                                setTimeout(() => this.showIdleWhisper(), i * 300);
                            }
                            keySequence.length = 0;
                        }

                        // "666" - Heavy glitch storm
                        if (keySequence.slice(-3).join('') === '666') {
                            for (let i = 0; i < 3; i++) {
                                setTimeout(() => this.triggerHeavyGlitch(), i * 200);
                            }
                            keySequence.length = 0;
                        }

                        // "blood" - Red screen pulse
                        if (keySequence.slice(-5).join('') === 'blood') {
                            this.triggerBloodPulse();
                            keySequence.length = 0;
                        }
                    });
                }

                triggerBloodPulse() {
                    const bloodGlow = document.getElementById('blood-glow');
                    if (!bloodGlow) return;

                    animate(
                        bloodGlow,
                        {
                            opacity: [0.8, 1, 0.95, 1, 0.8],
                            filter: ['brightness(1)', 'brightness(2) saturate(2)', 'brightness(1.5)', 'brightness(2)', 'brightness(1)']
                        } as any,
                        { duration: 2, easing: 'ease-in-out' } as any
                    );

                    this.playJumpscareSound();
                }

                // ============================================
                // RANDOM EVENTS
                // ============================================
                setupRandomEvents() {
                    // Consolidated timer for better performance - runs every 4 seconds
                    let ticks = 0;

                    setInterval(() => {
                        ticks++;

                        // Screen flicker - every 2 ticks (8s)
                        if (ticks % 2 === 0 && Math.random() < 0.08) {
                            this.screenFlicker();
                        }

                        // Text distortion - every 3 ticks (12s)
                        if (ticks % 3 === 0 && Math.random() < 0.12) {
                            this.distortRandomText();
                        }

                        // Screen invert - every 5 ticks (20s)
                        if (ticks % 5 === 0 && Math.random() < 0.04) {
                            this.triggerScreenInvert();
                        }

                        // Split screen - every 6 ticks (24s, close to 25s)
                        if (ticks % 6 === 0 && Math.random() < 0.06) {
                            this.triggerSplitScreen();
                        }

                        // Vignette close - every 7 ticks (28s, close to 30s)
                        if (ticks % 7 === 0 && Math.random() < 0.05) {
                            this.triggerVignetteClose();
                        }

                        // Blood rain - every 10 ticks (40s)
                        if (ticks % 10 === 0 && Math.random() < 0.03) {
                            this.triggerBloodRain();
                        }

                        // Reset ticks counter after LCM to prevent overflow (420 = LCM of 2,3,5,6,7,10)
                        if (ticks >= 420) ticks = 0;
                    }, 4000);
                }

                screenFlicker() {
                    const body = document.body;

                    animate(
                        body,
                        { filter: ['brightness(1)', 'brightness(0.3)', 'brightness(1.5)', 'brightness(0.5)', 'brightness(1)'] } as any,
                        { duration: 0.13, easing: 'steps(4)' } as any
                    );
                }

                triggerScreenInvert() {
                    const body = document.body;

                    animate(
                        body,
                        {
                            filter: [
                                'invert(0)',
                                'invert(1)',
                                'invert(1)',
                                'invert(0)'
                            ]
                        } as any,
                        { duration: 0.3, easing: 'steps(3)' } as any
                    );
                }

                triggerSplitScreen() {
                    const body = document.body;

                    animate(
                        body,
                        {
                            x: [0, -20, 20, -10, 10, 0],
                            filter: [
                                'none',
                                'hue-rotate(180deg)',
                                'saturate(3)',
                                'contrast(2)',
                                'brightness(0.5)',
                                'none'
                            ]
                        } as any,
                        { duration: 0.5, easing: 'ease-out' } as any
                    );

                    this.triggerStaticBurst();
                }

                triggerVignetteClose() {
                    const vignette = document.getElementById('vignette');
                    if (!vignette) return;

                    animate(
                        vignette,
                        {
                            opacity: [1, 1.5, 1.3, 1],
                            filter: [
                                'brightness(1)',
                                'brightness(0.3)',
                                'brightness(0.5)',
                                'brightness(1)'
                            ]
                        } as any,
                        { duration: 2, easing: 'ease-in-out' } as any
                    );
                }

                triggerBloodRain() {
                    const bloodGlow = document.getElementById('blood-glow');
                    if (!bloodGlow) return;

                    animate(
                        bloodGlow,
                        {
                            opacity: [0.8, 1.2, 0.9, 1.1, 0.8],
                            y: [0, -20, -10, -15, 0],
                            filter: [
                                'brightness(1) blur(0px)',
                                'brightness(2) blur(5px)',
                                'brightness(1.5) blur(2px)',
                                'brightness(1.8) blur(3px)',
                                'brightness(1) blur(0px)'
                            ]
                        } as any,
                        { duration: 3, easing: 'ease-in-out' } as any
                    );
                }

                distortRandomText() {
                    const paragraphs = document.querySelectorAll('main p');
                    if (paragraphs.length === 0) return;

                    const p = paragraphs[Math.floor(Math.random() * paragraphs.length)];

                    // Choose random effect type
                    const effectType = Math.floor(Math.random() * 4);

                    switch(effectType) {
                        case 0: // Color shift
                            animate(
                                p,
                                {
                                    color: ['inherit', '#990000', 'inherit'],
                                    textShadow: ['none', '0 0 10px rgba(153, 0, 0, 0.6)', 'none']
                                } as any,
                                { duration: 2, easing: 'ease-in-out' } as any
                            );
                            break;

                        case 1: // Rotation + skew
                            animate(
                                p,
                                {
                                    rotate: [0, 2, -2, 1, 0],
                                    skewX: [0, -3, 3, 0],
                                    textShadow: ['none', '2px 2px 8px rgba(153, 0, 0, 0.8)', 'none']
                                } as any,
                                { duration: 1.5, easing: 'ease-in-out' } as any
                            );
                            break;

                        case 2: // Scale + blur
                            animate(
                                p,
                                {
                                    scale: [1, 1.03, 0.97, 1],
                                    filter: ['blur(0px)', 'blur(2px)', 'blur(1px)', 'blur(0px)'],
                                    color: ['inherit', '#cc0000', '#990000', 'inherit']
                                } as any,
                                { duration: 1.8, easing: 'ease-in-out' } as any
                            );
                            break;

                        case 3: // Letter spacing glitch
                            animate(
                                p,
                                {
                                    letterSpacing: ['normal', '0.3em', '-0.05em', '0.1em', 'normal'],
                                    color: ['inherit', '#ff0000', '#990000', 'inherit'],
                                    textShadow: [
                                        'none',
                                        '3px 0 #cc0000, -3px 0 #990000',
                                        '0 3px #cc0000, 0 -3px #990000',
                                        'none'
                                    ]
                                } as any,
                                { duration: 1.2, easing: [0.4, 0, 0.6, 1] } as any
                            );
                            break;
                    }

                    if (Math.random() < 0.3) {
                        this.playGlitchSound();
                    }
                }
            }

            // Single instance of horror engine
            let horrorEngine: BloodHorrorEngine | null = null;

            // Updates the active navigation link indicator during view transitions
            // Handles Astro's client-side navigation without page refresh
            function updateActiveNavLink() {
                // Normalize current path with trailing slash
                let currentPath = window.location.pathname;
                if (!currentPath.endsWith('/')) {
                    currentPath += '/';
                }

                // Update active class on all nav links
                const navLinks = document.querySelectorAll('nav a');
                navLinks.forEach(link => {
                    link.classList.remove('active');

                    // Check if link href matches current path
                    const linkHref = link.getAttribute('href');
                    if (linkHref === currentPath) {
                        link.classList.add('active');
                    }
                });
            }

            function initHorrorEngine() {
                if (!horrorEngine) {
                    horrorEngine = new BloodHorrorEngine();
                } else {
                    // On page swap, just reinitialize page-specific animations
                    horrorEngine.setupPageLoad();
                }
            }

            // Initialize on first load
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    initHorrorEngine();
                    updateActiveNavLink();
                });
            } else {
                initHorrorEngine();
                updateActiveNavLink();
            }

            // Reinitialize page content on Astro navigation
            document.addEventListener('astro:after-swap', () => {
                if (horrorEngine) {
                    horrorEngine.setupPageLoad();
                }
            });

            // Update active nav link on Astro page transitions
            document.addEventListener('astro:page-load', updateActiveNavLink);
        </script>
    </body>
</html>
